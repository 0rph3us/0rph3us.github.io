<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sicherheit on Michael im Netz</title>
    <link>https://0rph3us.github.io/categories/sicherheit/</link>
    <description>Recent content in Sicherheit on Michael im Netz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>de-DE</language>
    <copyright>Diese Seite ist unter der &lt;a href=&#34;http://creativecommons.org/licenses/by-sa/4.0/&#34;&gt;Creative Commons Attribution-ShareAlike 4.0 International License&lt;/a&gt; lizenziert.</copyright>
    <lastBuildDate>Mon, 28 Dec 2015 22:37:08 +0100</lastBuildDate>
    <atom:link href="https://0rph3us.github.io/categories/sicherheit/rss/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LibreSSL und HAProxy</title>
      <link>https://0rph3us.github.io/post/2015/12/libressl-und-haproxy/</link>
      <pubDate>Mon, 28 Dec 2015 22:37:08 +0100</pubDate>
      
      <guid>https://0rph3us.github.io/post/2015/12/libressl-und-haproxy/</guid>
      <description>

&lt;p&gt;Wenn man &lt;a href=&#34;https://www.raspbian.org/&#34;&gt;Raspbian&lt;/a&gt; einsetzt (oder eine fast beliebige andere Linux-Distribution)
hat man das &lt;em&gt;Problem&lt;/em&gt;, dass die mitgelieferten Webserver und Loadbalancer &lt;a href=&#34;https://www.openssl.org/&#34;&gt;OpenSSL&lt;/a&gt;
nutzen. OpenSSL ist 2015 durch eine Sicherheitslücken negativ aufgefallen, außerdem
gibt es keine Unterstützung&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:bddda923aec4e8e8e36a0066c730c514:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:bddda923aec4e8e8e36a0066c730c514:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; für &lt;a href=&#34;https://blog.cloudflare.com/do-the-chacha-better-mobile-performance-with-cryptography/&#34;&gt;ChaCha20 Cipher Suiten&lt;/a&gt;. Diese haben den Vorteil,
dass sie in Software schneller sind als &lt;a href=&#34;https://de.wikipedia.org/wiki/Advanced_Encryption_Standard&#34;&gt;AES&lt;/a&gt;. Das macht sich insbesondere bei meinen
Raspberry Pi und bei Smartphones bemerkbar. Diese haben Hardware AES.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.libressl.org/&#34;&gt;LibreSSL&lt;/a&gt; ist eine Alternative zu OpenSSL. Es hat die Unterstützung für ChaCha20. Bei
LibreSSL liegt der Fokus auf Sicherheit und weniger auf die Unterstützung von alten
Schnittstellen. Deswegen ist davon auszugehen, dass es in der Zukunft auch weniger
kritische Sicherheitslücken geben wird.&lt;/p&gt;

&lt;h2 id=&#34;haproxy:bddda923aec4e8e8e36a0066c730c514&#34;&gt;HAProxy&lt;/h2&gt;

&lt;p&gt;In meinen Setup ist &lt;a href=&#34;http://www.haproxy.org/&#34;&gt;HAProxy&lt;/a&gt; vor dem Webserver (Nginx). Es ist vielleicht sinnlos
einen Loadbalancer auf dem Pi zu nutzen aber ich finde, dass sich HAProxy ein einigen
Stellen einfacher konfigurieren lässt als Nginx.&lt;/p&gt;

&lt;h2 id=&#34;haproxy-mit-libressl-und-pcre-bauen:bddda923aec4e8e8e36a0066c730c514&#34;&gt;HAProxy mit LibreSSL und PCRE bauen&lt;/h2&gt;

&lt;p&gt;kopiere das folgende Script in eine Datei und führe es aus:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash

# names of latest versions of each package
export HAPROXY_VERSION=1.6.3
export VERSION_PCRE=pcre-8.38
export VERSION_LIBRESSL=libressl-2.3.1
export VERSION_HAPROXY=haproxy-$HAPROXY_VERSION

# URLs to the source directories
export SOURCE_LIBRESSL=ftp://ftp.openbsd.org/pub/OpenBSD/LibreSSL/
export SOURCE_PCRE=ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/
export SOURCE_HAPROXY=http://www.haproxy.org/download


# clean out any files from previous runs of this script
rm -rf build
mkdir build

# proc for building faster
NB_PROC=$(grep -c ^processor /proc/cpuinfo)

# ensure that we have the required software
#sudo apt-get -y install curl wget build-essential libgd-dev libgeoip-dev checkinstall git

# grab the source files
echo &amp;quot;Download sources&amp;quot;
wget -P ./build &amp;quot;${SOURCE_PCRE}${VERSION_PCRE}.tar.gz&amp;quot;
wget -P ./build &amp;quot;${SOURCE_LIBRESSL}${VERSION_LIBRESSL}.tar.gz&amp;quot;
wget -P ./build &amp;quot;${SOURCE_HAPROXY}/$(echo $HAPROXY_VERSION | cut -d. -f 1-2)/src/$VERSION_HAPROXY.tar.gz&amp;quot;

# expand the source files
echo &amp;quot;Extract Packages&amp;quot;
cd build || exit 1

tar xfz &amp;quot;${VERSION_HAPROXY}.tar.gz&amp;quot;
tar xfz &amp;quot;${VERSION_LIBRESSL}.tar.gz&amp;quot;
tar xfz &amp;quot;${VERSION_PCRE}.tar.gz&amp;quot;
cd ../ || exit 1

export BPATH=&amp;quot;${PWD}/build&amp;quot;
export STATICLIBSSL=&amp;quot;${BPATH}/${VERSION_LIBRESSL}&amp;quot;

# build static LibreSSL
echo &amp;quot;Configure &amp;amp; Build LibreSSL&amp;quot;
cd &amp;quot;${STATICLIBSSL}&amp;quot; || exit 1
./configure --prefix=&amp;quot;${STATICLIBSSL}/_openssl/&amp;quot; --enable-shared=no &amp;amp;&amp;amp; make install-strip -j &amp;quot;${NB_PROC}&amp;quot;

# build pcre
export STATICLIPCRE=&amp;quot;${BPATH}/${VERSION_PCRE}&amp;quot;
cd &amp;quot;${STATICLIPCRE}&amp;quot; || exit 1
./configure --prefix=&amp;quot;${STATICLIPCRE}/_pcre&amp;quot; --enable-shared=no --enable-utf8 --enable-jit
make -j &amp;quot;${NB_PROC}&amp;quot;
make install


echo &amp;quot;Build HAProxy&amp;quot;
cd &amp;quot;${BPATH}/${VERSION_HAPROXY}&amp;quot; || exit 1

make \
-j &amp;quot;${NB_PROC}&amp;quot; \
TARGET=linux2628 \
USE_STATIC_PCRE=1 \
USE_PCRE_JIT=1 \
PCRE_LIB=&amp;quot;${STATICLIPCRE}/_pcre/lib&amp;quot; \
PCRE_INC=&amp;quot;${STATICLIPCRE}/_pcre/include&amp;quot; \
USE_OPENSSL=1 \
SSL_INC=&amp;quot;${STATICLIBSSL}/_openssl/include&amp;quot; \
SSL_LIB=&amp;quot;${STATICLIBSSL}/_openssl/lib&amp;quot; \
USE_ZLIB=1 \
DEFINE=&amp;quot;-fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2&amp;quot;


echo &amp;quot;All done.&amp;quot;
echo &amp;quot;become root and type: &amp;quot;
echo &amp;quot;  cp build/haproxy-${HAPROXY_VERSION}/haproxy /usr/local/sbin&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;konfiguration:bddda923aec4e8e8e36a0066c730c514&#34;&gt;Konfiguration&lt;/h2&gt;

&lt;p&gt;Hier ist eine Beispielkonfiguration. Wobei die SSL Konfiguration sehr
paranoid ist.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global
        maxconn 100
        ssl-default-bind-ciphers CHACHA20+EECDH:AES256+EECDH
        ssl-default-bind-options force-tlsv12

        daemon
        user haproxy
        chroot /var/lib/haproxy
        stats socket /var/run/haproxy.sock mode 660 level admin


defaults
        mode http
        timeout connect 5s
        timeout client 5s
        timeout server 5s

        stats scope .

        option socket-stats
        option forwardfor


frontend myfrontend
        # primary cert is /etc/haproxy/certs/server.pem
        # /etc/haproxy/certs/ contains additional certificates for SNI clients
        bind :443 tfo ssl crt /etc/haproxy/certs/server.pem crt /etc/haproxy/certs/ ecdhe secp384r1 name ssl-traffic
        bind :80 name http-traffic

        http-response set-header X-Frame-Options                DENY
        http-response set-header X-Content-Type-Options         nosniff
        http-response set-header Strict-Transport-Security      max-age=31536000;\ includeSubdomains;\ preload

        http-request redirect scheme https code 301 if !{ ssl_fc }

        http-request set-header X-Forwarded-Proto                https


        use_backend stats               if { path_beg /haproxy/stats }

        default_backend mybackend


backend mybackend
        # a http backend
        server s3 10.0.0.3:80
        server s4 10.0.0.3:443 ssl verify none


backend stats
        stats enable
        stats show-legends
        stats realm Haproxy\ Statistics
        stats uri /haproxy/stats
        stats refresh 30s

&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:bddda923aec4e8e8e36a0066c730c514:1&#34;&gt;In den kommenden Versionen von OpenSSL wird es Unterstützung für ChaCha20 Cipher Suiten geben. Ich finde die Quelle gerade nicht :-(
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:bddda923aec4e8e8e36a0066c730c514:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Guten Morgen</title>
      <link>https://0rph3us.github.io/post/2015/09/guten-morgen/</link>
      <pubDate>Tue, 15 Sep 2015 05:50:08 +0200</pubDate>
      
      <guid>https://0rph3us.github.io/post/2015/09/guten-morgen/</guid>
      <description>

&lt;p&gt;Ich habe schon länger keinen neuen Post hinterlassen. Es
lag unter anderen daran, dass ich umgezogen bin. Der größte
Teil des Umzuges ist inzwischen geschafft und alles ist an
seinen Platz.&lt;/p&gt;

&lt;p&gt;In der Zwischenzeit war nicht untätig, Ich habe mit &lt;a href=&#34;http://www.haproxy.org/&#34;&gt;HAProxy&lt;/a&gt;
etwas experimentiert. Ziel war es Zertifikate mit RSA und &lt;a href=&#34;http://www.cs.uni-potsdam.de/ti/lehre/05-Kryptographie/slides/Elliptische_Kurven.pdf&#34;&gt;Elliptische Kurven&lt;/a&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3fd9ce4c42cd011d05713db9016f8f87:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3fd9ce4c42cd011d05713db9016f8f87:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; für den selben Hostname/FQDN anzubieten.&lt;/p&gt;

&lt;p&gt;Weswegen möchte man das eigenlich machen? Zertifikate mit
RSA sind sehr lang (größergleich 4096 Bit), wenn man
paranoit ist. Diese langen Zertifikate kosten Zeit bei der Übertragung und Rechenkraft beim Handshake. Aus diesem Grud liegt es nahe Zertifikate mit Elliptischen Kurven zu nutzen. Die größten Kurven haben eine Länge von 571 Bit. Dabei wird eine sehr höhere Sicherheit erreicht, als mit 8096 Bit langen RSA Schlüssel und sie lassen schneller berechnen.&lt;/p&gt;

&lt;p&gt;Da ich auf meinen Raspberry Pi zahlreiche Dienste betreibe, welche per SSL abgesichert sind, habe ich Stern-Zertifiake generiert. Wenn HAProxy eine eigene (Sub)&lt;a href=&#34;https://de.wikipedia.org/wiki/Zertifizierungsstelle&#34;&gt;CA&lt;/a&gt; hat, dann ist es möglich, dass bei jeder Anfrage mit einen neuen Hostname ein neues Zertifikat generiert wird.&lt;/p&gt;

&lt;h2 id=&#34;umsetzung:3fd9ce4c42cd011d05713db9016f8f87&#34;&gt;Umsetzung&lt;/h2&gt;

&lt;p&gt;In den aktuellen Developer Builds von HAProxy, aktuell 1.6-dev4 ist möglich ECC und RSA Zertifikate auf der selben IP und Port zu betreiben. Weiherhin ist es möglich Zertifikate zu generieren. Das dumme war nur, dass es nicht richtig mit Elliptischen Kurven funktioniert. Nach einiger Diskussion über den Sinn dieses Setups hat mit Christopher Faulet einen Patch geschieben, welcher funktioniert. Da der Patch auch bei mir funktioniert, gibt Christopher upstream.&lt;/p&gt;

&lt;h3 id=&#34;testconfig:3fd9ce4c42cd011d05713db9016f8f87&#34;&gt;Testconfig&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;global
        daemon
        maxconn 256

        ssl-default-bind-ciphers AES256+EECDH:AES256+EDH
        ssl-default-bind-options force-tlsv12
        tune.ssl.default-dh-param 4096
        tune.ssl.lifetime 600


defaults
        mode http
        timeout connect 5000ms
        timeout client 50000ms
        timeout server 50000ms


frontend ssl-relay
        mode tcp
        bind 0.0.0.0:443

        use_backend ssl-ecc if { req.ssl_ec_ext 1 }
        default_backend ssl-ecc


backend ssl-ecc
        mode tcp

        server ecc unix@/var/run/haproxy_ssl_ecc.sock send-proxy-v2


backend ssl-rsa
        mode tcp

        server rsa unix@/var/run/haproxy_ssl_rsa.sock send-proxy-v2


listen webfarm
        bind unix@/var/run/haproxy_ssl_ecc.sock accept-proxy ssl crt /etc/haproxy/ecc_test.rennecke.dyndns.dk.pem tls-ticket-keys /etc/haproxy/ticket_keys ca-sign-file /etc/haproxy/ecc_subca.pem user nobody generate-certificates ecdhe secp521r1
        bind unix@/var/run/haproxy_ssl_rsa.sock accept-proxy ssl crt /etc/haproxy/rsa_star.rennecke.dyndns.dk.pem tls-ticket-keys /etc/haproxy/ticket_keys ecdhe secp521r1 user nobody
        mode http

        acl admin               path_beg /haproxy
        use_backend admin       if admin

        server nginx 127.0.0.1:88 check

backend admin
        stats enable
        stats hide-version
        stats show-legends
        stats realm Haproxy\ Statistics
        stats uri /haproxy?stats
        stats refresh 30s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In dieser Config generiere ich nur die ECC-Zertifikate für alle Hosts, außer &lt;code&gt;test.rennecke.dyndns.dk&lt;/code&gt;. Das ganze Setup funktioniert, aber es läuft noch nicht ganz rund.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:3fd9ce4c42cd011d05713db9016f8f87:1&#34;&gt;Man schreibt auch oft &lt;a href=&#34;https://de.wikipedia.org/wiki/Elliptic_Curve_Cryptography&#34;&gt;ECC&lt;/a&gt; (Elliptic Curve) Cryptography
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3fd9ce4c42cd011d05713db9016f8f87:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Eine eigene CA mit OpenSSL in 5 Minuten</title>
      <link>https://0rph3us.github.io/post/2015/07/eine-eigene-ca-mit-openssl-in-5-minuten/</link>
      <pubDate>Tue, 07 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://0rph3us.github.io/post/2015/07/eine-eigene-ca-mit-openssl-in-5-minuten/</guid>
      <description>

&lt;p&gt;Wenn man seine eigenen Dienste mit SSL/&lt;a href=&#34;https://de.wikipedia.org/wiki/Transport_Layer_Security&#34;&gt;TLS&lt;/a&gt; absichern möchte benötigt man Zertifikate. Inzwischen
gibt es auch kostenlose Zertifikate, diese haben aber Einschränkungen. Wenn man dynDNS verwendet bekommt
man keine offizellen Zertifikate, da man nicht der Eigentümer der Domain ist. Oft hat jeder Dienst, den man
anbietet auch einen eigene Subdomain. Wenn man mehrere Subdomains auf dem selben Port benötigt man ein
Wildcard-Zertifikat&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:116aed65bb730b226540f3cd4bf4c27a:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:116aed65bb730b226540f3cd4bf4c27a:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Dieses ist nach meinen Kenntnisstand nicht kostenlos zu bekommen.&lt;/p&gt;

&lt;p&gt;Wenn man nicht nur einen Webserver, sondern auch einen Jabber-Server betreibt lohnt es sich eine eigene
CA (Certificate Authority) betreiben, mit der man alle seine Zertifikate unterschreibt. Damit alle Clients
der CA vertrauen muss diese nur bekannt machen. Danach wird allen Zertifikaten vertraut, welche von der CA
unterschrieben wurden.&lt;/p&gt;

&lt;p&gt;Ein weiterer Vorteil: Mit der eigenen CA ist man im Zweifel auf der sicheren Seite. In den letzten Jahren
ist es öfter vorgekommen, dass gefälschte Zertifikate im Umlauf waren. Es gibt also Gründe den großen
CAs zu misstrauen&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:116aed65bb730b226540f3cd4bf4c27a:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:116aed65bb730b226540f3cd4bf4c27a:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h2 id=&#34;certificate-authority-erstellen:116aed65bb730b226540f3cd4bf4c27a&#34;&gt;Certificate Authority erstellen&lt;/h2&gt;

&lt;p&gt;Als erstes muss man einen geheimen privaten Schlüssel generieren:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;openssl genrsa -aes256 -out ca-key.pem 4096
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Der Schlüssel wird in der Datei &lt;code&gt;ca-key.pem&lt;/code&gt; gespeichert und hat eine Länge von 4096 Bit. Man kann auch einen
längeren bzw. kürzeren Schlüssel erzeugen. 2048 Bit sehe ich als absolutes Minimum an. Durch Verwendung der
Option &lt;code&gt;-aes256&lt;/code&gt; wird der Schküssel mit einem Passwort geschützt. Der Schlüssel der CA muss besonderst
geschützt werden, denn mit ihm könnte sich ein Angreifer beliebige Zertifikate ausstellen. Die Verschlüsselung
mit einem Passwort bietet einen zusätzlichen Schutz. Das Passwort muss man bei jeder Verwendung des Schlüssels
eingeben.&lt;/p&gt;

&lt;p&gt;Als nächstes muss man das root-Zertifikat der CA erzeugen. Dieses kann man dann in die Browser und in die
Betriebssysteme importieren. Das Zertifikat wird wie folgt generiert:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;openssl req -x509 -new -nodes -extensions v3_ca -key ca-key.pem -days 3650 -out ca-root.pem -sha512
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dieses Zertifikat hat eine Gültigkeit von 10 Jahren (3650 Tage). Die Attribute der CA können wie folgt sein:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Country Name (2 letter code) [AU]:DE
State or Province Name (full name) [Some-State]:Saxony-Anhalt
Locality Name (eg, city) []:Halle (Saale)
Organization Name (eg, company) [Internet Widgits Pty Ltd]:bude
Organizational Unit Name (eg, section) []:IT
Common Name (eg, YOUR name) []:example.net
Email Address []:meine.email-adresse.net
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;root-zertifikat-auf-den-clients-importieren:116aed65bb730b226540f3cd4bf4c27a&#34;&gt;Root-Zertifikat auf den Clients importieren&lt;/h2&gt;

&lt;h3 id=&#34;debian-ubuntu:116aed65bb730b226540f3cd4bf4c27a&#34;&gt;Debian / Ubuntu&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo cp ca-root.pem /usr/share/ca-certificates/myca-root.crt
sudo dpkg-reconfigure ca-certificates
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mozilla-firefox-thunderbird:116aed65bb730b226540f3cd4bf4c27a&#34;&gt;Mozilla Firefox / Thunderbird&lt;/h3&gt;

&lt;p&gt;Mozilla Firefox verwaltet Zertifikate selbst. Ein neues Zertifikat wird importiert unter &lt;em&gt;Einstellungen&lt;/em&gt; =&amp;gt; &lt;em&gt;Erweitert&lt;/em&gt; =&amp;gt; &lt;em&gt;Zertifikate&lt;/em&gt; =&amp;gt; &lt;em&gt;Zertifikate anzeigen&lt;/em&gt; =&amp;gt; &lt;em&gt;Zertifizierungsstellen&lt;/em&gt; =&amp;gt; &lt;em&gt;Importieren&lt;/em&gt;. Wählt die Datei &lt;code&gt;ca-root.pem&lt;/code&gt; aus. Wählt die Option &lt;em&gt;Dieser CA vertrauen, um Websites zu identifizieren&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;chromium-google-chrome:116aed65bb730b226540f3cd4bf4c27a&#34;&gt;Chromium / Google Chrome&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Einstellungen&lt;/em&gt; =&amp;gt; &lt;em&gt;Erweiterte Einstellungen anzeigen&lt;/em&gt; (unten) =&amp;gt; &lt;em&gt;HTTPS/SSL&lt;/em&gt; =&amp;gt; &lt;em&gt;Zertifikate verwalten&lt;/em&gt; =&amp;gt; &lt;em&gt;Zertifizierungsstellen&lt;/em&gt; =&amp;gt; &lt;em&gt;Importieren&lt;/em&gt; =&amp;gt; &lt;code&gt;ca-root-pem&lt;/code&gt; auswählen =&amp;gt; &lt;em&gt;Diesem Zertifikat zur Identifizierung von Websites vertrauen&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;ein-neues-zertifikat-ausstellen:116aed65bb730b226540f3cd4bf4c27a&#34;&gt;Ein neues Zertifikat ausstellen&lt;/h2&gt;

&lt;p&gt;Als erstes muss man sich wieder einen privaten Schlüssel erzeuge.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;openssl genrsa -out cert-key.pem 4096
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bei den Zertifikaten sollte man in den meisten Fällen kein Passwort setzten. Wenn man es z.B. für einen Webserver benötigt,
dann müsste man das Passwort bei jedem Start eingeben.&lt;/p&gt;

&lt;p&gt;Nun muss man eine Zertifikatsanfrage erstellen. Ganz wichtig ist der &lt;strong&gt;Common Name&lt;/strong&gt; dieses Attribut &lt;em&gt;muss&lt;/em&gt; so lauten, wie der Hostname
des Servers, auf den es ausgestellt ist. Wenn man nur via IP zugreifen möchte, dann ist der Common Name die IP, mit den man den Dienst
ansprechen möchte. Es sind auch Wildcard-zertifikate möchte *.example.com gilt für foo.example.com bar.example.com, aber nicht für foo.bar.example.com.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;openssl req -new -key cert-key.pem -out cert.csr -sha512
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wenn man fertig ist, dann erhält man die Zertifikatsanfrage in &lt;code&gt;cert.csr&lt;/code&gt;, die kann von CA weiter verarbeitet werden. Dabei wird der öffentliche
Schlüssel des angefragten Zertifikats.&lt;/p&gt;

&lt;p&gt;Mit der root-CA, deren Schlüssel und der Zertifikatsanfrage erstellt man ein signiertes Zertifikat, welches 1 Jahr gültig ist.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;openssl x509 -req -in cert.csr -CA ca-root.pem -CAkey ca-key.pem -CAcreateserial -out cert-pub.pem -days 365 -sha512
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Openssl fragt nach dem dem Passwort der root-CA. Wenn dan signierte Zertifikat erstellt wurde kann man die Zertifikatsanfrage &lt;code&gt;cert.csr&lt;/code&gt; löschen.
Das öffentliche Zertifikat befindet sich in der Datei &lt;code&gt;cert-pub.pem&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;das-zertifikat-benutzen:116aed65bb730b226540f3cd4bf4c27a&#34;&gt;Das Zertifikat benutzen&lt;/h2&gt;

&lt;p&gt;Für einen Webserver benötigt man die folgenden 3 Teile:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Privater Schlüssel des Zertifikats &lt;code&gt;cert-key.pem&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Öffentlicher Schlüssel des Zertifikats &lt;code&gt;cert-pub.pem&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Öffentlicher Schlüssel der CA &lt;code&gt;ca-root.pem&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Je nach Server ist es nötig die CA und den öffentlichen Schlüssel in einer Datei zu haben. Das kann man wie folgt machen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat ca-root.pem &amp;gt;&amp;gt; cert-pub.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;wenn sie SNI nicht unterstützen. Eine weitere Alternative sind SAN-Zertifikate (diese sind auf mehrere Subdomains ausgestellt), diese gibt es auch nicht für lau.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:116aed65bb730b226540f3cd4bf4c27a:1&#34;&gt;Seit TLS 1.0 kann man auch durch &lt;a href=&#34;https://de.wikipedia.org/wiki/Server_Name_Indication&#34;&gt;SNI&lt;/a&gt; mehrere Zertifikate nutzen. SNI unterstützen ältere Browser noch nicht, evtl. hat man auch mit Apps Probleme,
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:116aed65bb730b226540f3cd4bf4c27a:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:116aed65bb730b226540f3cd4bf4c27a:2&#34;&gt;Dazu muss sie aber aus seinen Browser und Betriebssystem löschen. Das ist nicht unbedingt sehr sinnvoll.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:116aed65bb730b226540f3cd4bf4c27a:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Passwortmanager</title>
      <link>https://0rph3us.github.io/post/2015/02/passwortmanager/</link>
      <pubDate>Wed, 11 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>https://0rph3us.github.io/post/2015/02/passwortmanager/</guid>
      <description>

&lt;p&gt;Jeder kennt das Problem mit dem Passwörtern. Man sollte nicht überall das selbe Passwort verwenden,
außerdem sollte man es regelmäßig wechseln und dann muss es auch noch &lt;em&gt;komplex&lt;/em&gt; sein. Da ich mir
nicht 100 Passwörter merken kann, verwende ich einen Passwortmanager. Es gibt eine ganze Reihe
von solchen Tools, aber keins hat mich mich bis überzeugt.&lt;/p&gt;

&lt;h3 id=&#34;meine-anforderungen-sind:723e36c0d653eead54808cb1e59efd78&#34;&gt;Meine Anforderungen sind&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;einfach zu bedienen&lt;/li&gt;
&lt;li&gt;einfache synchronisation zwischen mehreren Geräten&lt;/li&gt;
&lt;li&gt;leichtgewichtig&lt;/li&gt;
&lt;li&gt;eine GUI ist nicht nötig&lt;/li&gt;
&lt;li&gt;Windowsunterstützung ist mir egal, da ich kein Windows nutze&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://keepass.info/&#34;&gt;KeePass 2&lt;/a&gt; würde meine meisten Anforderungen erfüllen. Aber ich werde mit dem Tool nicht wirklich warm. Ich finde auch, dass
es recht schwergewichtig ist, weil ich dafür noch &lt;a href=&#34;http://www.mono-project.com/&#34;&gt;Mono&lt;/a&gt; benötige, was ich sonst nicht auf meinen Rechnern habe.&lt;/p&gt;

&lt;h2 id=&#34;pass-der-standard-unix-passwortmanager:723e36c0d653eead54808cb1e59efd78&#34;&gt;pass - Der Standard Unix Passwortmanager&lt;/h2&gt;

&lt;p&gt;Nachdem ich &lt;a href=&#34;http://www.passwordstore.org/&#34;&gt;pass&lt;/a&gt; gefunden habe, war ich glücklich. Dieser Passwortmanager hat alles was ich verlange.
Das schöne ist, dass pass auf Standarttools setzt. Die Daten werden mit &lt;a href=&#34;https://www.gnupg.org/&#34;&gt;GnuPG&lt;/a&gt; verschlüsselt und bei Bedarf
in einen &lt;a href=&#34;http://git-scm.com/&#34;&gt;git&lt;/a&gt;-Repository versioniert. Durch die Verwendung von git ist es auch möglich die Passwörter über
verschiedene Clients hinweg zu sychronisieren.&lt;/p&gt;

&lt;p&gt;Man kann &lt;a href=&#34;http://www.passwordstore.org/&#34;&gt;pass&lt;/a&gt; über die Paketverwaltung der meisten Distributionen installieren. Es ist auch ohne weiteres
möglich pass via git checkout zu installieren. Das geht deswegen so einfach, weil pass &lt;em&gt;nur&lt;/em&gt; ein Shell-Skript
ist, welches einige Standarttools sowie GnuPG und git nutzt.&lt;/p&gt;

&lt;h3 id=&#34;anwendung:723e36c0d653eead54808cb1e59efd78&#34;&gt;Anwendung&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pass init EE75C6FE
mkdir: created directory ‘/home/rennecke/.password-store’
Password store initialized for EE75C6FE Password Storage Key.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Es wird eine leere Passwortdatenbank erstellt und zum verschküsseln der Passwörter wird der GnuPG Key &lt;code&gt;EE75C6FE&lt;/code&gt;
verwenden. Man kann den Key auch mit der dazugehörigen Emailadresse angeben.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pass git init 
Initialized empty Git repository in /home/rennecke/.password-store/.git/ 
[master (root-commit) 998c8fd] Added current contents of password store. 
1 file changed, 1 insertion(+) 
create mode 100644 .gpg-id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jetzt wird noch leere Passwortdatenbank unter Versionskontrolle genommen. Nun kann alle Möglichkeiten
von git nutzen. Die &lt;code&gt;&amp;lt;parameter&amp;gt;&lt;/code&gt; von &lt;code&gt;pass git &amp;lt;parameter&amp;gt;&lt;/code&gt; sind alle möglichen Parameter, welche git
aktzeptiert, &lt;code&gt;pass&lt;/code&gt; alles was nach git kommt 1:1 an &lt;code&gt;git&lt;/code&gt; weiter.&lt;/p&gt;

&lt;p&gt;An dieser Stelle möchte ich nicht die Dokumentation von pass abschreiben, da ich es auch recht intuitiv finde. Man
kann sich &lt;a href=&#34;http://git.zx2c4.com/password-store/about/#EXTENDED%20GIT%20EXAMPLE&#34;&gt;hier&lt;/a&gt; einen Überblick verschaffen.&lt;/p&gt;

&lt;h3 id=&#34;android-app:723e36c0d653eead54808cb1e59efd78&#34;&gt;Android App&lt;/h3&gt;

&lt;p&gt;Für alle Android-Nutzer gibt es noch ein richtiges Sahnestück, die App &lt;a href=&#34;https://github.com/zeapo/Android-Password-Store&#34;&gt;Password Store&lt;/a&gt;. Sie überzeugt mich, durch ein
gutes Bedienkonzept und sie kann alle Funktionen von pass nutzen. Sie unterstützt auch mit einem Passwort gesicherte
ssh-Schlüssel. Zur Verwaltung der GnuPG-Schlüssel nutzte ich &lt;a href=&#34;http://www.openkeychain.org/&#34;&gt;OpenKeychain&lt;/a&gt;. OpenKeychain unterstüzt selbstverständlich
auch mit einem Passwort gesicherte private Schlüssel.&lt;/p&gt;

&lt;h3 id=&#34;nachtrag:723e36c0d653eead54808cb1e59efd78&#34;&gt;Nachtrag&lt;/h3&gt;

&lt;p&gt;Wie ihr im letzten Absatz bemerkt habt, muss ich mir trotzdem 2 Passwörter merken und bei KeyPass 2 ist es nur ein Passwort.
Das ist aber kein Nachteil in meinen Augen. Jeder der ssh- und GnuPG-Schlüssel nutzt sollte sie mit einen Passwort sichern,
falls das Gerät, auf dem sich der Schlüssel befindet kompromitiert wird. Die Passwörter muss man sich einfach merken, wenn
man täglich diese Schlüssel nutzt.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Chrome und selbst signierte Zertifikate</title>
      <link>https://0rph3us.github.io/post/2014/08/chrome-und-selbst-signierte-zertifikate/</link>
      <pubDate>Fri, 29 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://0rph3us.github.io/post/2014/08/chrome-und-selbst-signierte-zertifikate/</guid>
      <description>

&lt;p&gt;Heute habe ich festgestellt, dass Google den &lt;a href=&#34;http://www.google.de/intl/de/chrome/browser/&#34;&gt;Chrome&lt;/a&gt;-Browser (Version 37.0.2062.94 (64-Bit))
verhunzt hat. Es gibt jetzt einen &lt;strong&gt;Privacy Error&lt;/strong&gt; wenn eine Seite, wie dieser Blog,
ein selbst signiertes SSL-Zertifikat benutzt. Bis jetzt gab es einen &lt;strong&gt;SSL Error&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;chromium:c1300b2c90762b5984abb067105b084d&#34;&gt;Chromium&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;The site&#39;s security certificate is not trusted!

You attempted to reach blog.rennecke.dyndns.dk, but the server presented a certificate
issued by an entity that is not trusted by your computer&#39;s operating system. This may 
mean that the server has generated its own security credentials, which Chromium cannot 
rely on for identity information, or an attacker may be trying to intercept your communications.

You should not proceed, especially if you have never seen this warning before for this site.

Proceed anyway       Back to safety
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;chome-jetzt:c1300b2c90762b5984abb067105b084d&#34;&gt;Chome jetzt&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Your connection is not private

Attackers might be trying to steal your information from blog.rennecke.dyndns.dk 
(for example, passwords, messages, or credit cards).

advanced    Back to safety
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Diese Meldung finde ich unter aller Sau! Verdient Google auch an den Zertifikatverkäufen oder weswegen
muss der Hinweis so drastisch ausfallen, dass ein nicht technikaffiner Nutzer nicht mehr auf meinen
Blog kommt? Erst wenn man &lt;em&gt;advanced&lt;/em&gt; ausklappt hat man die Möglichkeit auf die Seit zu kommen. In
Zeiten von Abhörskandalen darf man nicht selbst signierte Zertifikate boykottieren. So wächst nur
die Hemmschwelle SSL einzusetzen.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sichere E-Mails</title>
      <link>https://0rph3us.github.io/post/2013/10/sichere-e-mails/</link>
      <pubDate>Wed, 02 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://0rph3us.github.io/post/2013/10/sichere-e-mails/</guid>
      <description>&lt;p&gt;Nachdem ich &lt;a href=&#34;http://www.golem.de/news/gesellschaft-fuer-informatik-wir-brauchen-sichere-standardisierung-der-verschluesselung-1310-101928.html&#34;&gt;diesen Beitrag auf golem.de&lt;/a&gt;
gelesen habe, ist mir wieder die ganze Misere mit &lt;a href=&#34;http://www.de-mail.de&#34;&gt;De-Mail&lt;/a&gt; und dem NSA-Skandal hoch gekommen.&lt;/p&gt;

&lt;p&gt;Vielleicht denke ich zu einfach, oder habe anderen Denkfehler, aber kann Sicherheit und
&lt;a href=&#34;http://de.wikipedia.org/wiki/Ende-zu-Ende-Verschl%C3%BCsselung&#34;&gt;Ende-zu-Ende-Verschlüsselung&lt;/a&gt; nicht einfach sein?
Ich nutze seit einigen Jahren &lt;a href=&#34;http://www.gnupg.org/&#34;&gt;GnuPG&lt;/a&gt; und &lt;a href=&#34;https://www.enigmail.net&#34;&gt;Enigmail&lt;/a&gt; für &lt;a href=&#34;http://www.thunderbird-mail.de/&#34;&gt;Thunderbird&lt;/a&gt;.
Damit ist es mir und meinen Kommunikationspartnern möglich, dass wir die Mails signieren und verschlüsseln können.
Ich gebe zu, dass die Verwendung etwas komplizierter ist, als eine normale Mail ist. Im Großen und Ganzen halte
ich das Verfahren für E-Mail-Provider und Behörden umsetzbar und ein Dritter hat es schwer die Nachricht zu lesen
bzw. verändern.  Es ist Möglich, dass man Keys widerrufen kann und, dass man sie austauscht.&lt;/p&gt;

&lt;p&gt;Die Dinge, die oben beschrieben sind, sind doch Anforderungen für eine moderne verschlüsselte Mail. Weswegen wir das neu erfunden,
anstatt etwas vorhandenes zu vereinfachen bzw. Regeln über Algorithmen und Schlüssellängen festlegen?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Neuer GPG-Key</title>
      <link>https://0rph3us.github.io/post/2013/09/neuer-gpg-key/</link>
      <pubDate>Mon, 09 Sep 2013 00:00:00 +0000</pubDate>
      
      <guid>https://0rph3us.github.io/post/2013/09/neuer-gpg-key/</guid>
      <description>&lt;p&gt;Nach den ganzen &lt;a href=&#34;http://www.nsa.gov/&#34;&gt;NSA&lt;/a&gt;-Enthüllungen, habe ich mich wieder mit Public-Key-Kryptografie beschäftigt. Mein bisheriger &lt;a href=&#34;http://www.gnupg.org/&#34;&gt;GPG&lt;/a&gt;-Schüssel D12E87BA hat &lt;a href=&#34;http://www.itl.nist.gov/fipspubs/fip186.htm&#34;&gt;DSA&lt;/a&gt; und &lt;a href=&#34;http://de.wikipedia.org/wiki/Elgamal-Verschl%C3%BCsselungsverfahren&#34;&gt;ElGamal&lt;/a&gt; verwendet. Ich habe damals diese Algorithmen damals gewählt, da ich keinen &#34;Standard-Key&#34; haben wollte. Die Längen sind auch nach heutigen Maßstäben ausreichend. Es aber &lt;a href=&#34;http://rdist.root.org/2010/11/19/dsa-requirements-for-random-k-value/&#34;&gt;Angriffe für DSA&lt;/a&gt;, welche darauf beruhen, dass die Zufallszahlen von Zufallszahlengeneratoren nicht zufällig sind. Da ich meinen Schlüssel auf beliebigen Rechnern und auch Endgeräten nutzen möchte, kann ich nicht immer sicher stellen, dass der Zufallszahlengenerator wirklich korrekt seine Arbeit macht. Aus diesem Grund habe ich mir ein neues Schlüsselpaar mit &lt;a href=&#34;http://de.wikipedia.org/wiki/RSA-Kryptosystem&#34;&gt;RSA&lt;/a&gt; zum verschlüsseln und signieren erstellt.&lt;/p&gt;
&lt;p&gt;Es ist nicht ganz unwahrscheinlich, dass &lt;a href=&#34;http://news.cnet.com/8301-13578_3-57591560-38/facebooks-outmoded-web-crypto-opens-door-to-nsa-spying/&#34;&gt;große Organisationen 1024 Bit RSA Schüssel faktorisieren&lt;/a&gt; können. Ein Schlüssellänge von 2048 Bit gilt als sicher und 4096 Bit als paranoid. Ich bin lieber paranoid und nehme 4096 lange Schlüssel, da diese Schüssellänge auf heutigen Rechnern kein Problem darstellt und von fast allen Implementieren von GPG unterstützt wird.&lt;/p&gt;
&lt;p&gt;Mein neuer Key ist &lt;a href=&#34;http://pgp.mit.edu:11371/pks/lookup?op=vindex&amp;amp;search=0x617EB806EE75C6FE&#34;&gt;EE75C6FE&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>