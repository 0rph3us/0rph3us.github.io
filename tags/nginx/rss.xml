<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nginx on Michael im Netz</title>
    <link>http://localhost:1313/tags/nginx/</link>
    <description>Recent content in Nginx on Michael im Netz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>de-DE</language>
    <copyright>Diese Seite ist unter der &lt;a href=&#34;http://creativecommons.org/licenses/by-sa/4.0/&#34;&gt;Creative Commons Attribution-ShareAlike 4.0 International License&lt;/a&gt; lizenziert.</copyright>
    <lastBuildDate>Tue, 07 Jul 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/nginx/rss/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Eine eigene CA mit OpenSSL in 5 Minuten</title>
      <link>http://localhost:1313/post/2015/07/eine-eigene-ca-mit-openssl-in-5-minuten/</link>
      <pubDate>Tue, 07 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/2015/07/eine-eigene-ca-mit-openssl-in-5-minuten/</guid>
      <description>

&lt;p&gt;Wenn man seine eigenen Dienste mit SSL/&lt;a href=&#34;https://de.wikipedia.org/wiki/Transport_Layer_Security&#34;&gt;TLS&lt;/a&gt; absichern möchte benötigt man Zertifikate. Inzwischen
gibt es auch kostenlose Zertifikate, diese haben aber Einschränkungen. Wenn man dynDNS verwendet bekommt
man keine offizellen Zertifikate, da man nicht der Eigentümer der Domain ist. Oft hat jeder Dienst, den man
anbietet auch einen eigene Subdomain. Wenn man mehrere Subdomains auf dem selben Port benötigt man ein
Wildcard-Zertifikat&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:116aed65bb730b226540f3cd4bf4c27a:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:116aed65bb730b226540f3cd4bf4c27a:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Dieses ist nach meinen Kenntnisstand nicht kostenlos zu bekommen.&lt;/p&gt;

&lt;p&gt;Wenn man nicht nur einen Webserver, sondern auch einen Jabber-Server betreibt lohnt es sich eine eigene
CA (Certificate Authority) betreiben, mit der man alle seine Zertifikate unterschreibt. Damit alle Clients
der CA vertrauen muss diese nur bekannt machen. Danach wird allen Zertifikaten vertraut, welche von der CA
unterschrieben wurden.&lt;/p&gt;

&lt;p&gt;Ein weiterer Vorteil: Mit der eigenen CA ist man im Zweifel auf der sicheren Seite. In den letzten Jahren
ist es öfter vorgekommen, dass gefälschte Zertifikate im Umlauf waren. Es gibt also Gründe den großen
CAs zu misstrauen&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:116aed65bb730b226540f3cd4bf4c27a:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:116aed65bb730b226540f3cd4bf4c27a:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h2 id=&#34;certificate-authority-erstellen:116aed65bb730b226540f3cd4bf4c27a&#34;&gt;Certificate Authority erstellen&lt;/h2&gt;

&lt;p&gt;Als erstes muss man einen geheimen privaten Schlüssel generieren:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;openssl genrsa -aes256 -out ca-key.pem 4096
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Der Schlüssel wird in der Datei &lt;code&gt;ca-key.pem&lt;/code&gt; gespeichert und hat eine Länge von 4096 Bit. Man kann auch einen
längeren bzw. kürzeren Schlüssel erzeugen. 2048 Bit sehe ich als absolutes Minimum an. Durch Verwendung der
Option &lt;code&gt;-aes256&lt;/code&gt; wird der Schküssel mit einem Passwort geschützt. Der Schlüssel der CA muss besonderst
geschützt werden, denn mit ihm könnte sich ein Angreifer beliebige Zertifikate ausstellen. Die Verschlüsselung
mit einem Passwort bietet einen zusätzlichen Schutz. Das Passwort muss man bei jeder Verwendung des Schlüssels
eingeben.&lt;/p&gt;

&lt;p&gt;Als nächstes muss man das root-Zertifikat der CA erzeugen. Dieses kann man dann in die Browser und in die
Betriebssysteme importieren. Das Zertifikat wird wie folgt generiert:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;openssl req -x509 -new -nodes -extensions v3_ca -key ca-key.pem -days 3650 -out ca-root.pem -sha512
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dieses Zertifikat hat eine Gültigkeit von 10 Jahren (3650 Tage). Die Attribute der CA können wie folgt sein:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;Country Name (2 letter code) [AU]:DE
State or Province Name (full name) [Some-State]:Saxony-Anhalt
Locality Name (eg, city) []:Halle (Saale)
Organization Name (eg, company) [Internet Widgits Pty Ltd]:bude
Organizational Unit Name (eg, section) []:IT
Common Name (eg, YOUR name) []:example.net
Email Address []:meine.email-adresse.net
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;root-zertifikat-auf-den-clients-importieren:116aed65bb730b226540f3cd4bf4c27a&#34;&gt;Root-Zertifikat auf den Clients importieren&lt;/h2&gt;

&lt;h3 id=&#34;debian-ubuntu:116aed65bb730b226540f3cd4bf4c27a&#34;&gt;Debian / Ubuntu&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo cp ca-root.pem /usr/share/ca-certificates/myca-root.crt
sudo dpkg-reconfigure ca-certificates
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mozilla-firefox-thunderbird:116aed65bb730b226540f3cd4bf4c27a&#34;&gt;Mozilla Firefox / Thunderbird&lt;/h3&gt;

&lt;p&gt;Mozilla Firefox verwaltet Zertifikate selbst. Ein neues Zertifikat wird importiert unter &lt;em&gt;Einstellungen&lt;/em&gt; =&amp;gt; &lt;em&gt;Erweitert&lt;/em&gt; =&amp;gt; &lt;em&gt;Zertifikate&lt;/em&gt; =&amp;gt; &lt;em&gt;Zertifikate anzeigen&lt;/em&gt; =&amp;gt; &lt;em&gt;Zertifizierungsstellen&lt;/em&gt; =&amp;gt; &lt;em&gt;Importieren&lt;/em&gt;. Wählt die Datei &lt;code&gt;ca-root.pem&lt;/code&gt; aus. Wählt die Option &lt;em&gt;Dieser CA vertrauen, um Websites zu identifizieren&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;chromium-google-chrome:116aed65bb730b226540f3cd4bf4c27a&#34;&gt;Chromium / Google Chrome&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Einstellungen&lt;/em&gt; =&amp;gt; &lt;em&gt;Erweiterte Einstellungen anzeigen&lt;/em&gt; (unten) =&amp;gt; &lt;em&gt;HTTPS/SSL&lt;/em&gt; =&amp;gt; &lt;em&gt;Zertifikate verwalten&lt;/em&gt; =&amp;gt; &lt;em&gt;Zertifizierungsstellen&lt;/em&gt; =&amp;gt; &lt;em&gt;Importieren&lt;/em&gt; =&amp;gt; &lt;code&gt;ca-root-pem&lt;/code&gt; auswählen =&amp;gt; &lt;em&gt;Diesem Zertifikat zur Identifizierung von Websites vertrauen&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;ein-neues-zertifikat-ausstellen:116aed65bb730b226540f3cd4bf4c27a&#34;&gt;Ein neues Zertifikat ausstellen&lt;/h2&gt;

&lt;p&gt;Als erstes muss man sich wieder einen privaten Schlüssel erzeuge.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;openssl genrsa -out cert-key.pem 4096
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bei den Zertifikaten sollte man in den meisten Fällen kein Passwort setzten. Wenn man es z.B. für einen Webserver benötigt,
dann müsste man das Passwort bei jedem Start eingeben.&lt;/p&gt;

&lt;p&gt;Nun muss man eine Zertifikatsanfrage erstellen. Ganz wichtig ist der &lt;strong&gt;Common Name&lt;/strong&gt; dieses Attribut &lt;em&gt;muss&lt;/em&gt; so lauten, wie der Hostname
des Servers, auf den es ausgestellt ist. Wenn man nur via IP zugreifen möchte, dann ist der Common Name die IP, mit den man den Dienst
ansprechen möchte. Es sind auch Wildcard-zertifikate möchte *.example.com gilt für foo.example.com bar.example.com, aber nicht für foo.bar.example.com.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;openssl req -new -key cert-key.pem -out cert.csr -sha512
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wenn man fertig ist, dann erhält man die Zertifikatsanfrage in &lt;code&gt;cert.csr&lt;/code&gt;, die kann von CA weiter verarbeitet werden. Dabei wird der öffentliche
Schlüssel des angefragten Zertifikats.&lt;/p&gt;

&lt;p&gt;Mit der root-CA, deren Schlüssel und der Zertifikatsanfrage erstellt man ein signiertes Zertifikat, welches 1 Jahr gültig ist.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;openssl x509 -req -in cert.csr -CA ca-root.pem -CAkey ca-key.pem -CAcreateserial -out cert-pub.pem -days 365 -sha512
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Openssl fragt nach dem dem Passwort der root-CA. Wenn dan signierte Zertifikat erstellt wurde kann man die Zertifikatsanfrage &lt;code&gt;cert.csr&lt;/code&gt; löschen.
Das öffentliche Zertifikat befindet sich in der Datei &lt;code&gt;cert-pub.pem&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;das-zertifikat-benutzen:116aed65bb730b226540f3cd4bf4c27a&#34;&gt;Das Zertifikat benutzen&lt;/h2&gt;

&lt;p&gt;Für einen Webserver benötigt man die folgenden 3 Teile:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Privater Schlüssel des Zertifikats &lt;code&gt;cert-key.pem&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Öffentlicher Schlüssel des Zertifikats &lt;code&gt;cert-pub.pem&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Öffentlicher Schlüssel der CA &lt;code&gt;ca-root.pem&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Je nach Server ist es nötig die CA und den öffentlichen Schlüssel in einer Datei zu haben. Das kann man wie folgt machen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat ca-root.pem &amp;gt;&amp;gt; cert-pub.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;wenn sie SNI nicht unterstützen. Eine weitere Alternative sind SAN-Zertifikate (diese sind auf mehrere Subdomains ausgestellt), diese gibt es auch nicht für lau.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:116aed65bb730b226540f3cd4bf4c27a:1&#34;&gt;Seit TLS 1.0 kann man auch durch &lt;a href=&#34;https://de.wikipedia.org/wiki/Server_Name_Indication&#34;&gt;SNI&lt;/a&gt; mehrere Zertifikate nutzen. SNI unterstützen ältere Browser noch nicht, evtl. hat man auch mit Apps Probleme,
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:116aed65bb730b226540f3cd4bf4c27a:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:116aed65bb730b226540f3cd4bf4c27a:2&#34;&gt;Dazu muss sie aber aus seinen Browser und Betriebssystem löschen. Das ist nicht unbedingt sehr sinnvoll.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:116aed65bb730b226540f3cd4bf4c27a:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>RSS Reader selbst betreiben</title>
      <link>http://localhost:1313/post/2014/09/rss-reader-selbst-betreiben/</link>
      <pubDate>Wed, 17 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/2014/09/rss-reader-selbst-betreiben/</guid>
      <description>

&lt;p&gt;Nach meinen Wissen gab es eine Zeit, in der RSS-Feeds als Old-School und damit
als nicht mehr zeitgemäß galten. Ich finde, dass sie zur Zeit immer beliebter
werden. Ich möchte meine Feeds immer dabei und nicht viele Apps auf dem Smartphone
installieren, nur um meinen 20 News-Seiten zu folgen. Das ganze im Browser zu
lesen kann auf mobilen Devices nervig werden, entweder ist die mobile Seite nicht
wirklich brauchbar oder man hat zu viele Seite, welche man lesen möchte.&lt;/p&gt;

&lt;p&gt;Da viele Seiten einen &lt;a href=&#34;http://de.wikipedia.org/wiki/Web-Feed&#34;&gt;Feed&lt;/a&gt; anbieten, kann man diese abonnieren und in einen
Feed-Reader zusammen führen. Es gibt Menschen, wie mich, die keinen Reader wie
&lt;a href=&#34;http://feedly.com/&#34;&gt;Feedly&lt;/a&gt; nutzen möchten.&lt;/p&gt;

&lt;p&gt;Mit einem &lt;a href=&#34;http://www.raspberrypi.org/&#34;&gt;Raspberry Pi&lt;/a&gt; kann man einfach selbst einen RSS-Reader an der heimischen
DSL-Leitung betreiben. Dazu benutze ich &lt;a href=&#34;http://nginx.org/&#34;&gt;Nginx&lt;/a&gt; als Webserver, &lt;a href=&#34;http://www.mysql.de/&#34;&gt;MySQL&lt;/a&gt; als Datenbank
sowie &lt;a href=&#34;http://tt-rss.org/&#34;&gt;Tiny Tiny RSS&lt;/a&gt; als Reader. Als Betriebssystem nutze ich Raspbian.&lt;/p&gt;

&lt;h2 id=&#34;nginx-installieren:589edeb4b03d933707b2122f6cfd44ac&#34;&gt;Nginx installieren&lt;/h2&gt;

&lt;p&gt;Wie man &lt;a href=&#34;http://nginx.org/&#34;&gt;Nginx&lt;/a&gt; installiert, habe ich in &lt;a href=&#34;http://localhost:1313/post/2014/07/webserver-auf-dem-raspberry-pi-installieren/&#34;&gt;diesem Artikel&lt;/a&gt; schon erklärt.
Je nach dem wie paranoid bzw. nerdig man ist, sollte man die Verbindung noch
mit SSL/TLS absichern.&lt;/p&gt;

&lt;h2 id=&#34;mysql-installieren:589edeb4b03d933707b2122f6cfd44ac&#34;&gt;MySQL installieren&lt;/h2&gt;

&lt;p&gt;Die grundlegende Installation von MySQL geht leicht von der Hand. Da man nur einige
Pakte installieren muss. Die nötige Datenbank ist auch schnell eingerichtet.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# zu root werden
sudo su -

apt-get update
apt-get install mysql-server mysql-client php5-mysql php5-curl

# Datenbanken einrichten
mysql -p
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
[...]
mysql&amp;gt; CREATE DATABASE ttrss;
Query OK, 1 row affected (0.01 sec)
 
mysql&amp;gt; GRANT ALL ON ttrss.* TO ttrss@localhost IDENTIFIED BY &#39;GeheimesPasswort&#39;;
Query OK, 0 rows affected (0.02 sec)
 
mysql&amp;gt; exit
Bye
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mysql-härten:589edeb4b03d933707b2122f6cfd44ac&#34;&gt;MySQL härten&lt;/h3&gt;

&lt;p&gt;Mit dem folgenden Tool kann man seine MySQL noch härten. Dazu löscht
es die Test-Datenbanken und anonyme Benutzer. Weiterhin ist ein
Remote Login für den Benutzer &lt;code&gt;root&lt;/code&gt; nicht mehr möglich.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# zu root werden
sudo su -
mysql_secure_installation
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tiny-tiny-rss-installieren:589edeb4b03d933707b2122f6cfd44ac&#34;&gt;Tiny Tiny RSS installieren&lt;/h2&gt;

&lt;p&gt;Man lädt sich die &lt;a href=&#34;https://github.com/gothfox/Tiny-Tiny-RSS/releases&#34;&gt;aktuellste Version&lt;/a&gt; von &lt;a href=&#34;http://tt-rss.org/&#34;&gt;Tiny Tiny RSS&lt;/a&gt; in das Document Root-Verzeichnis
von Nginx und entpackt es&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# zu root werden
sudo su -
cd /usr/share/nginx/www
wget https://github.com/gothfox/Tiny-Tiny-RSS/archive/1.13.tar.gz
tar xfvz 1.13.tar.gz
mv Tiny-Tiny-RSS-1.13/ tt-rss/
chown -R www-data:www-data tt-rss/
rm 1.13.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nachdem man das alles gemacht hat, führt man die Installation von Tiny Tiny RSS im Browser fort. Dazu
&lt;code&gt;http(s)://IP/tt-rss/install/&lt;/code&gt;
Dort wählen wir MySQL in dem Feld &lt;em&gt;Database type&lt;/em&gt;, geben als &lt;em&gt;Username&lt;/em&gt; und &lt;em&gt;Database name&lt;/em&gt;
&lt;em&gt;ttrss&lt;/em&gt; an und geben das Passwort, welches für den MySQL Benutzer &lt;em&gt;ttrss&lt;/em&gt; angelegt hat,
in das Feld &lt;em&gt;Password&lt;/em&gt; ein. Der Port ist 3306. In das Feld &lt;em&gt;Host name&lt;/em&gt; schreiben wir 127.0.0.1
Anschließend klicken wir auf &lt;em&gt;Test configuration&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Wenn alles richtig war, dann erscheint &lt;em&gt;Database test succeeded&lt;/em&gt;. Nach einem Klick auf
&lt;em&gt;Initialize database&lt;/em&gt; können wir aus der Textbox die Konfiguration kopieren.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo su -
cat &amp;lt;&amp;lt; EOF &amp;gt; /usr/share/nginx/www/tt-rss/config.php
kopierten Text hier einfügen
EOF  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;feeds-aktualisieren:589edeb4b03d933707b2122f6cfd44ac&#34;&gt;Feeds aktualisieren&lt;/h3&gt;

&lt;p&gt;Dazu muss man die folgende Zeile in die &lt;code&gt;crontab&lt;/code&gt; von &lt;code&gt;root&lt;/code&gt; eintragen:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*/30 * * * * su www-data -s /bin/bash -c &#39;/usr/bin/php /var/www/tt-rss/update.php --feeds --quiet&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;tiny-tiny-rss-für-das-smartphone:589edeb4b03d933707b2122f6cfd44ac&#34;&gt;Tiny Tiny RSS für das Smartphone&lt;/h2&gt;

&lt;p&gt;Es gibt zwei Android Clients für Tiny Tiny RSS. Diese haben beide den Nachteil, dass sie unter Umständen
Probleme mit den Ciphers der SSL Verschlüsselung haben. Da das bei mir der Fall war bin ich auf eine HTML
App umgestiegen, welche auch noch auf meinen Raspberry Pi läuft. Dazu muss man nur &lt;a href=&#34;https://github.com/mboinet/ttrss-mobile/archive/1.0-1.tar.gz&#34;&gt;dieses Archiv&lt;/a&gt; herunter
laden und entpacken, alternativ kann man auch das &lt;a href=&#34;https://github.com/mboinet/ttrss-mobile&#34;&gt;dazugehörige git-Repository&lt;/a&gt; klonen.&lt;/p&gt;

&lt;p&gt;Man muss vorher sicherstellen, dass der API-Zugriff zu Tiny Tiny RSS erlaubt ist. Man loggt sich als ersten
in TT-RSS ein und klickt dann auf &lt;em&gt;Aktionen&lt;/em&gt; -&amp;gt; &lt;em&gt;Einstellungen&lt;/em&gt; und &lt;em&gt;Aktiviere API-Zugang&lt;/em&gt; muss ein grünes
Häkchen haben (wenn nicht anklicken).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo su -
cd /usr/share/nginx/www
wget https://github.com/mboinet/ttrss-mobile/archive/1.0-1.tar.gz
tar xfvz 1.0-1.tar.gz
mv ttrss-mobile-1.0-1 mobile
cp mobile/scripts/conf.js{-dist,}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nun kann man unter &lt;code&gt;http(s)://IP/mobile/&lt;/code&gt; die HTML5 Anwendung für das Smartphone erreichen.&lt;/p&gt;

&lt;h2 id=&#34;schlussbemerkung:589edeb4b03d933707b2122f6cfd44ac&#34;&gt;Schlussbemerkung&lt;/h2&gt;

&lt;p&gt;Soll der soeben installierte Dienst auch außerhalb des eigenen Netzwerkes verfügbar sein, so müssen
folgende Ports (80 und 443) im Router freigegeben werden.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Webserver auf dem Raspberry Pi installieren</title>
      <link>http://localhost:1313/post/2014/07/webserver-auf-dem-raspberry-pi-installieren/</link>
      <pubDate>Thu, 31 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/2014/07/webserver-auf-dem-raspberry-pi-installieren/</guid>
      <description>

&lt;p&gt;Da man auf dem &lt;a href=&#34;http://www.raspberrypi.org/&#34;&gt;Raspberry Pi&lt;/a&gt; nicht sehr viele Ressourcen zur Verfügung hat, scheidet &lt;a href=&#34;http://httpd.apache.org/&#34;&gt;Apache&lt;/a&gt; als
Webserver für mich aus. Ich habe &lt;a href=&#34;http://www.lighttpd.net/&#34;&gt;lighttpd&lt;/a&gt; und &lt;a href=&#34;http://nginx.org&#34;&gt;Nginx&lt;/a&gt; ausprobiert. Von &lt;a href=&#34;http://www.lighttpd.net/&#34;&gt;lighttpd&lt;/a&gt; war ich am
Anfang sehr überzeugt. Er kann alles was man benötigt. Als mein Setup komplizierter wurde, war
ich nicht mehr in Lage in die Ideen mit &lt;a href=&#34;http://www.lighttpd.net/&#34;&gt;lighttpd&lt;/a&gt; umzusetzen. Die Ursache liegt weniger im
Funktionsumfang, sondern an den zur Verfügung stehenden Tutorials, Beispielkonfigurationen sowie der
Default-Konfiguration wenn man &lt;a href=&#34;http://www.lighttpd.net/&#34;&gt;lighttpd&lt;/a&gt; bei Raspbian installiert. Den endgültigen &lt;em&gt;Todesstoß&lt;/em&gt; hat
&lt;a href=&#34;http://www.lighttpd.net/&#34;&gt;lighttpd&lt;/a&gt; bekommen, als ich &lt;a href=&#34;https://www.phusionpassenger.com/&#34;&gt;Passanger&lt;/a&gt; ausprobieren wollte. Für &lt;a href=&#34;http://httpd.apache.org/&#34;&gt;Apache&lt;/a&gt; und &lt;a href=&#34;http://nginx.org&#34;&gt;Nginx&lt;/a&gt; gibt es fertige
&lt;a href=&#34;https://www.phusionpassenger.com/&#34;&gt;Passanger&lt;/a&gt;-Module bzw. funktionierenden Install-Skripte. Ich möchte nicht sagen, dass &lt;a href=&#34;http://www.lighttpd.net/&#34;&gt;lighttpd&lt;/a&gt; schlechter
als &lt;a href=&#34;http://nginx.org&#34;&gt;Nginx&lt;/a&gt; ist, aber ich bin bei &amp;ldquo;komplexen&amp;rdquo; Setups mit mehreren virtuellen Hosts und rewrite-Magie
besser mit &lt;a href=&#34;http://nginx.org&#34;&gt;Nginx&lt;/a&gt; zurecht gekommen.&lt;/p&gt;

&lt;p&gt;Im folgenden werde ich mich auf &lt;a href=&#34;http://nginx.org&#34;&gt;Nginx&lt;/a&gt; &lt;em&gt;Engine-X&lt;/em&gt; konzentrieren. da es für ihn sehr viele Tutorials
gibt und er sehr ressourcenschonend ist, ist er meiner Meinung nach die erste Wahl für den &lt;a href=&#34;http://www.raspberrypi.org/&#34;&gt;Raspberry Pi&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Viele werden mit nur einen Webserver nicht glücklich, weil ein Webserver nur statische Inhalte ausliefert.
Damit Nginx php ausliefern kann benötigt man php auf seinen Rechner sowie den
PHP Fast CGI Process Manager. Dieser verwaltet php-Prozesse, welche wiederum statisches HTML generieren
und an den Nginx weiter geben.&lt;/p&gt;

&lt;h2 id=&#34;nginx-mit-php-installieren-und-einrichten:db017475119777d596b8e698842c0f61&#34;&gt;Nginx mit php installieren und einrichten&lt;/h2&gt;

&lt;p&gt;Vor der Installation von neuen Pakten sollte man nachsehen, ob es Updates gibt. Ein
sicherheitsbewusster Admin aktualisiert jeden Tag seine Systeme,
gerade wenn sie öffentlich erreichbar sind.&lt;/p&gt;

&lt;p&gt;{% highlight bash %}&lt;/p&gt;

&lt;h1 id=&#34;zu-root-werden:db017475119777d596b8e698842c0f61&#34;&gt;zu root werden&lt;/h1&gt;

&lt;p&gt;sudo su -&lt;/p&gt;

&lt;p&gt;apt-get update
apt-get upgrade&lt;/p&gt;

&lt;p&gt;apt-get install nginx php5-fpm php5-cgi php5-cli php5-common
{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;nginx-konfigurieren:db017475119777d596b8e698842c0f61&#34;&gt;Nginx konfigurieren&lt;/h3&gt;

&lt;p&gt;Wenn man nur einen virtuellen Host einrichten möchte, kann man die gesamte Konfiguration in der
&lt;code&gt;/etc/nginx/ningx.conf&lt;/code&gt; erledigen. Das Aufteilen der Konfiguration in mehrere Dateien macht diese
übersichtlicher. Somit ist es auch möglich virtuelle Host zu aktivieren und zu deaktivieren.&lt;/p&gt;

&lt;p&gt;Meine Empfehlung ist, dass jede Applikation/Seite ein eigener Host ist. So hat jede Applikation
ihr eigenes Log-File und eine übersichtliche Konfiguration.
Der Nachteil ist, dass man mehrere (Sub) Domains benötigt. Das ist nicht
mit allen Dyndns Anbietern möglich.&lt;/p&gt;

&lt;p&gt;Konfigurationen, welche global gültig sind, schreibe ich auch
in die &lt;code&gt;/etc/nginx/ningx.conf&lt;/code&gt;. Das sind z.B. ssl-Offloading, Redirekt zu https und die
ssl-Konfiguration.&lt;/p&gt;

&lt;p&gt;Das ist eine exemplarische Konfiguration eines Host, welcher php ausführt und auf Port 80 lauscht.
Der Host lauscht auf die Namen &lt;em&gt;localhost&lt;/em&gt; und &lt;em&gt;awesomephp.example.com&lt;/em&gt;. Port 80 ist der
Standardport für http. Wenn ihr nur einen Host konfiguriert habt (nur ein server-Abschnitt), dann
wird dieser immer genommen, unabhängig davon was im host-Header der Anfrage steht.&lt;/p&gt;

&lt;p&gt;{% highlight nginx %}
server {
    listen 80;
    server_name localhost awesomephp.example.com;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root /var/www/awesomephp;
index index.html index.php;

location / {
    try_files $uri $uri/ /index.php?$args;
}

location ~ ^(.+\.php)(.*)$ {
    try_files $fastcgi_script_name =404;
    fastcgi_split_path_info  ^(.+\.php)(.*)$;
    fastcgi_pass   unix:/var/run/php5-fpm.sock;
    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
    fastcgi_param  PATH_INFO        $fastcgi_path_info;
    include        /etc/nginx/fastcgi_params;
}

access_log      /var/log/nginx/awesome.access.log;
error_log       /var/log/nginx/awesome.error.log;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Nachdem der Nginx konfiguriert ist muss man die Konfiguration nur noch neu laden.&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
service nginx reload
{% endhighlight %}&lt;/p&gt;

&lt;h3 id=&#34;test-der-konfiguration:db017475119777d596b8e698842c0f61&#34;&gt;Test der Konfiguration&lt;/h3&gt;

&lt;p&gt;Nachdem der Nginx fehlerfrei seine Konfiguration neu geladen hat bzw. neu gestartet wurde kann man sie mit dem
folgenden Minimalbeispiel testen:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
mkdir -p /var/www/awesomephp
echo &amp;ldquo;&amp;lt;? phpinfo(); /&amp;gt;&amp;rdquo; &amp;gt; /var/www/awesomephp/info.php
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Wenn nur ein Host konfiguriert ist, dann kann man jetzt Browser &lt;code&gt;http://192.168.1.100/info.php&lt;/code&gt; aufrufen
und es erscheint eine Übersicht der php-Einstellungen. Ich gehe davon aus, dass der Raspberry Pi die IP
192.168.1.100 hat.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>