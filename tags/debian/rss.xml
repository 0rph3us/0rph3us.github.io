<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Debian on Michael im Netz</title>
    <link>https://0rph3us.github.io/tags/debian/</link>
    <description>Recent content in Debian on Michael im Netz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>de-DE</language>
    <copyright>Diese Seite ist unter der &lt;a href=&#34;http://creativecommons.org/licenses/by-sa/4.0/&#34;&gt;Creative Commons Attribution-ShareAlike 4.0 International License&lt;/a&gt; lizenziert.</copyright>
    <lastBuildDate>Thu, 01 Oct 2015 19:44:06 +0200</lastBuildDate>
    <atom:link href="https://0rph3us.github.io/tags/debian/rss/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Raspbian Jessie</title>
      <link>https://0rph3us.github.io/post/2015/10/raspbian-jessie/</link>
      <pubDate>Thu, 01 Oct 2015 19:44:06 +0200</pubDate>
      
      <guid>https://0rph3us.github.io/post/2015/10/raspbian-jessie/</guid>
      <description>&lt;p&gt;Seit dem 24.09.2015 gibt es die &lt;a href=&#34;https://www.raspberrypi.org/blog/raspbian-jessie-is-here/&#34;&gt;Raspbian&lt;/a&gt;-Version, welche auf &lt;a href=&#34;https://www.debian.org/News/2015/20150426&#34;&gt;Jessie&lt;/a&gt; basiert. Ich habe auch meinen Raspberry Pi ein Update auf die neue Version gegönnt.&lt;/p&gt;

&lt;p&gt;Es wird empfohlen, dass man eine Neuinstallation macht. Das habe ich auch gemacht. Vorher sollte man noch ein Backup von der SD-Karte machen.&lt;/p&gt;

&lt;p&gt;Die Installation und das Einspielen der Daten war kein Problem. Meine Anleitungen haben alle noch funktioniert, was die Installation der Software sehr einfach gemacht hat.&lt;/p&gt;

&lt;p&gt;Also viel Spaß beim Update.&lt;/p&gt;

&lt;p&gt;Ich werde in den nächsten Tagen noch einmal einen Artikel schreiben, wie man einfach ein Backup von der SD-Karte macht.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go in 6 Schritten installieren</title>
      <link>https://0rph3us.github.io/post/2015/02/go-in-6-schritten-installieren/</link>
      <pubDate>Thu, 26 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>https://0rph3us.github.io/post/2015/02/go-in-6-schritten-installieren/</guid>
      <description>

&lt;p&gt;Die Installation von &lt;a href=&#34;https://golang.org/&#34;&gt;go&lt;/a&gt; kann etwas tricky bei Debian und Ubuntu sein. Da die Versionen im Repository
veraltet sind. Manchmal ist es auch nötig mehrere Versionen der Programmierspache go parallel zu installieren.
Das ist mit Bordmitteln fast unmöglich.&lt;/p&gt;

&lt;p&gt;Für diese Probleme gibt es Abhilfe: Den go Versionsmanager &lt;a href=&#34;https://github.com/moovweb/gvm&#34;&gt;gvm&lt;/a&gt;. Ich gebe zu, dass das ganze etwas von einem
Rüttelskript hat, aber es funktioniert und ist nach meinen Wissen der einfachste Weg &lt;code&gt;go&lt;/code&gt; zu installieren&lt;/p&gt;

&lt;h3 id=&#34;1-voraussetzungen:68e336974a9292a1000070f844d9d073&#34;&gt;1. Voraussetzungen&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get install curl git mercurial make binutils bison gcc build-essential
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Damit installiert man die Voraussetzungen, um &lt;code&gt;go&lt;/code&gt; compilieren zu können.&lt;/p&gt;

&lt;h3 id=&#34;2-clone-das-repo-in-dein-home:68e336974a9292a1000070f844d9d073&#34;&gt;2. clone das Repo in Dein home&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;bash &amp;lt; &amp;lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Diese Komandozeile lädt mit &lt;a href=&#34;http://curl.haxx.se/&#34;&gt;curl&lt;/a&gt; ein Skript herunter und lässt es von der &lt;a href=&#34;http://www.gnu.org/software/bash/&#34;&gt;bash&lt;/a&gt; ausführen. Dabei
der Inhalt vom git-Repository nach &lt;code&gt;~/.gvm&lt;/code&gt; kopiert&lt;/p&gt;

&lt;h3 id=&#34;3-gvm-in-der-shell-verfügbar-machen:68e336974a9292a1000070f844d9d073&#34;&gt;3. gvm in der shell verfügbar machen&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[[ -s &amp;quot;$HOME/.gvm/scripts/gvm&amp;quot; ]] &amp;amp;&amp;amp; source &amp;quot;$HOME/.gvm/scripts/gvm&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Die Zeile muss man in seine &lt;code&gt;~/.bashrc&lt;/code&gt; bzw. &lt;code&gt;~/.zshrc&lt;/code&gt; einfügen, damit die Umgebungsvariablen und Komandos
von gvm in der jeweiligen shell verfügbar sind. Nach Änderung ist es nötig eine neue Shell zu öffnen oder man
führt das Komando noch einmal in der aktuellen Shell aus.&lt;/p&gt;

&lt;h3 id=&#34;4-nachsehen-ob-gvm-installiert-ist:68e336974a9292a1000070f844d9d073&#34;&gt;4. nachsehen, ob gvm installiert ist&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gvm version
Go Version Manager v1.0.22 installed at /home/rennecke/.gvm
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-go-golang-installieren:68e336974a9292a1000070f844d9d073&#34;&gt;5. go (golang) installieren&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gvm listall

gvm gos (available` sh
...
   go1.4
   go1.4.1
   go1.4.2
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Man sieht alle Versionen von &lt;code&gt;go&lt;/code&gt; So installiert man eine spezifische &lt;code&gt;go&lt;/code&gt; Version, z.B. 1.4.2.
&lt;em&gt;Installieren&lt;/em&gt; ist eigentlich der falsche Ausdruck, denn der neue go-Compiler wird compiliert,
d.h. es werden &lt;strong&gt;keine&lt;/strong&gt; Binärpakete heruntergeladen.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gvm install go1.4.2
Downloading Go source...
Installing go1.4...
* Compiling...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-gvm-mitteilen-welche-version-von-go-man-nutzen-möchte:68e336974a9292a1000070f844d9d073&#34;&gt;6. gvm mitteilen, welche Version von go man nutzen möchte&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gvm use go1.4.2
Now using version go1.4.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nun kann noch nachsehen, welche Version &lt;code&gt;go&lt;/code&gt; hat.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ go version
go version go1.4.2 linux/amd64
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Raspberry Pi auf Jessie updaten</title>
      <link>https://0rph3us.github.io/post/2014/07/raspberry-pi-auf-jessie-updaten/</link>
      <pubDate>Mon, 21 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>https://0rph3us.github.io/post/2014/07/raspberry-pi-auf-jessie-updaten/</guid>
      <description>

&lt;p&gt;Das aktuell Raspbian basiert auf Debian 7 &amp;ldquo;Wheezy&amp;rdquo;. Seit einiger Zeit gibt
es auch Raspbian Pakete für Debian 8 &amp;ldquo;Jessie&amp;rdquo;. Jessie ist der Nachfolger von &amp;ldquo;Wheezy&amp;rdquo;.
Die Pakete von &amp;ldquo;Jessie&amp;rdquo; sind um einiges aktueller, als die von &amp;ldquo;Wheezy&amp;rdquo;. Das bedeutet
aber, dass sie nicht unbedingt so stabil sein können. Ich habe bis jetzt noch keine
negativen Erfahrungen gemacht.&lt;/p&gt;

&lt;h3 id=&#34;aktualisierung-ausführen:91ca631d89320c543d2d97dabdf66c3d&#34;&gt;Aktualisierung ausführen&lt;/h3&gt;

&lt;p&gt;Die folgenden Schritte müssen alle als Benutzer &lt;strong&gt;root&lt;/strong&gt; ausgeführt werden. Entweder man
loggt sie als &lt;strong&gt;root&lt;/strong&gt; ein,  man schreibt &lt;code&gt;sudo&lt;/code&gt; vor jedes Komando oder man öffnet eine
root-Shell mit &lt;code&gt;sudo -i&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Man muss die &lt;code&gt;/etc/apt/sources.list&lt;/code&gt; editieren. Dazu öffnet man sie mit einem Editor
der Wahl (ich bevorzuge vi ;-)) und man ändert alle vorkommen von &lt;strong&gt;wheezy&lt;/strong&gt; in &lt;strong&gt;jessie&lt;/strong&gt;.
Das ganze lässt sich auch automatisch mit &lt;code&gt;sed&lt;/code&gt; machen.&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
cp /etc/apt/sources.list{,.$(date +%F)} &amp;amp;&amp;amp; sed -e &amp;rsquo;s/wheezy/jessie/g&amp;rsquo; -i /etc/apt/sources.list
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Wenn man nicht weiß was man macht, dann sollte man die Datei lieber per Hand editieren. Bei mir gibt es nur
eine Zeile und diese sollte dann wie folgt aussehen:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
deb &lt;a href=&#34;http://mirrordirector.raspbian.org/raspbian/&#34;&gt;http://mirrordirector.raspbian.org/raspbian/&lt;/a&gt; jessie main contrib non-free rpi
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Und nun muss man nur noch den Raspberry Pi updaten:&lt;/p&gt;

&lt;p&gt;{% highlight bash %}
apt-get update &amp;amp;&amp;amp; apt-get dist-upgrade
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;Das Update kann sehr lange dauern. Anschließend muss man den Raspberry Pi neu starten und das Update ist beendet!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Acrobat Reader für Debian wheezy</title>
      <link>https://0rph3us.github.io/post/2013/05/acrobat-reader-f%C3%BCr-debian-wheezy/</link>
      <pubDate>Mon, 13 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://0rph3us.github.io/post/2013/05/acrobat-reader-f%C3%BCr-debian-wheezy/</guid>
      <description>&lt;p&gt;Ich hatte heute wieder eine &lt;a href=&#34;http://www.adobe.com/devnet/pdf/pdf_reference.html&#34;&gt;pdf&lt;/a&gt; mit Formularen in,
welche in einen alternativen Viewer nicht wirklich funktioniert hat.
Den Arcobat Reader gibt es leider nicht als 64-Bit Paket, aber die 32-Bit Version tut auch ihren Dienst.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;echo &amp;quot;deb http://www.deb-multimedia.org wheezy main non-free&amp;quot; &amp;gt;&amp;gt; /etc/apt/sources.list
gpg --keyserver pgpkeys.mit.edu --recv-key 07DC563D1F41B907
gpg -a --export 07DC563D1F41B907 | apt-key add -
dpkg --add-architecture i386
apt-get update
apt-get install acroread
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;P.S.: Auf meinen Servern benutze ich &lt;code&gt;/etc/apt/sources.list.d/&amp;lt;listname&amp;gt;.list&lt;/code&gt; für zusätzliche Paketlisten.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Debian wheezy ist stable</title>
      <link>https://0rph3us.github.io/post/2013/05/debian-wheezy-ist-stable/</link>
      <pubDate>Sun, 05 May 2013 00:00:00 +0000</pubDate>
      
      <guid>https://0rph3us.github.io/post/2013/05/debian-wheezy-ist-stable/</guid>
      <description>&lt;p&gt;Seit gestern, den 04.05.2013 ist &lt;a href=&#34;http://www.debian.org/News/2013/20130504&#34;&gt;Debian Wheezy stable&lt;/a&gt;. Nun beginnt die gute Zeit für meine produktiven Systeme. Ich habe schon letzten Sommer einige Systeme auf Wheezy laufen, da ich ein paar Features benötigt habe bzw. haben wollte.&lt;/p&gt;
&lt;p&gt;Ich bin gespannt ob Unschönheiten/Bugs in &lt;a href=&#34;https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt&#34;&gt;cgroups&lt;/a&gt; gefixt wurden. Ich würde gerne mit Hilfe von cgroups die Stabilität eines Hadoop/Hypertable-Clusters erhöhen. Unter Vollast habe ich immer wieder mit partiellen Abstürzen zu kämpfen, was bei zu viel CPU-Last über Memory-Leaks bis zu Timeouts geht, also die gesamte Palette.&lt;/p&gt;
&lt;p&gt;P.S. Das mit dem Bild ist noch nicht vergessen ;-)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>verschlüsselte Volumes bequem mounten</title>
      <link>https://0rph3us.github.io/post/2011/03/verschl%C3%BCsselte-volumes-bequem-mounten/</link>
      <pubDate>Sat, 26 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>https://0rph3us.github.io/post/2011/03/verschl%C3%BCsselte-volumes-bequem-mounten/</guid>
      <description>&lt;p&gt;Ich habe mein home verschlüsselt. Dieses wird automatisch, beim anmelden gemountet.
Da ich in mein home noch ein paar andere verschlüsselte Dateisysteme einhänge funktionieren die Standard-Mittel,
wie &lt;code&gt;/etc/crypttab&lt;/code&gt; nicht. Dabei ergibt sich das folgende Problem: Die Volumes werden beim booten eingehangen
und zu diesen Zeitpunkt existiert mein home noch nicht.&lt;/p&gt;

&lt;p&gt;Da ich &lt;em&gt;faul&lt;/em&gt; bin möchte ich auch möglichst wenig Passwörter eingeben, weiterhin soll meine Freundin
auch den Rechner anmachen können und nicht an meinen Passwort scheitern. Deswegen wird nur mein
home via Passwort entschlüsselt, für die anderen Dateisysteme kommen &lt;em&gt;key-files&lt;/em&gt; zum Einsatz. Diese
liegen in meinen &lt;strong&gt;verschlüsselten&lt;/strong&gt; home.&lt;/p&gt;

&lt;p&gt;Da ich mir selbst nicht vertraue, möchte ich den &lt;a href=&#34;http://linux.die.net/man/8/sudo&#34;&gt;sudo&lt;/a&gt;-Mechanismus
oder &lt;a href=&#34;http://linux.die.net/man/2/setuid&#34;&gt;suid&lt;/a&gt;-Bits nicht benutzten. Deswegen habe ich mir die beiden
Skripte &lt;code&gt;cryptdisks_start&lt;/code&gt; und &lt;code&gt;cryptdisks_stop&lt;/code&gt; genauer angesehen. In einen ersten Schritt habe ich mir eine
&lt;code&gt;/etc/user_crypttab&lt;/code&gt; erzeugt.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;root@walhalla ~ # cat /etc/user_crypttab
# definition             volume                        key                                   options      mountpoint                mountoptions
data--group-video_crypt  /dev/mapper/data--group-video /home/rennecke/key-files/video-key    luks         /home/rennecke/Videos     noatime
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Die ersten vier Parameter entsprechen denen, der &lt;a href=&#34;http://linux.die.net/man/5/crypttab&#34;&gt;crypttab&lt;/a&gt;,
&lt;em&gt;mountpoint&lt;/em&gt; und &lt;em&gt;mountoptions&lt;/em&gt; sind entsprechen den gleichnamigen Optionen von
&lt;a href=&#34;http://linux.die.net/man/8/mount&#34;&gt;mount&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Mein &lt;code&gt;user_cryptdisks_start&lt;/code&gt;-Skript sieht wie folgt aus:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh

# user_cryptdisks_start - wrapper around cryptsetup which parses
# /etc/user_crypttab, just like mount parses /etc/fstab.

# Initial code stolen from cryptdisks_start by Jon Dowland &amp;lt;jon@alcopop.org&amp;gt;
# Copyright (C) 2011 by Michael Rennecke &amp;lt;michael_rennecke@gmx.net&amp;gt;
# License: GNU General Public License, v2 or any later
# (http://www.gnu.org/copyleft/gpl.html)

CRYPTTAB=&amp;quot;/etc/user_crypttab&amp;quot;

set -e

if [ $# -lt 1 ]; then
	echo &amp;quot;usage: $0 &amp;lt;name&amp;gt;&amp;quot; &amp;gt;&amp;amp;2
	echo &amp;gt;&amp;amp;2
	echo &amp;quot;reads $CRYPTTAB and starts the mapping corresponding to &amp;lt;name&amp;gt;&amp;quot; &amp;gt;&amp;amp;2
	exit 1
fi

. /lib/cryptsetup/cryptdisks.functions

INITSTATE=&amp;quot;manual&amp;quot;
DEFAULT_LOUD=&amp;quot;yes&amp;quot;

if [ -x &amp;quot;/usr/bin/id&amp;quot; ] &amp;amp;&amp;amp; [ &amp;quot;$(/usr/bin/id -u)&amp;quot;  != &amp;quot;0&amp;quot; ]; then
	log_warning_msg &amp;quot;$0 needs root privileges&amp;quot;
	exit 1
fi

log_action_begin_msg &amp;quot;Starting crypto disk&amp;quot;
mount_fs


count=0
tablen=&amp;quot;$(egrep -vc &amp;quot;^[[:space:]]*(#|$)&amp;quot; &amp;quot;$CRYPTTAB&amp;quot;)&amp;quot;
egrep -v &amp;quot;^[[:space:]]*(#|$)&amp;quot; &amp;quot;$CRYPTTAB&amp;quot; | while read dst src key opts mnt mopts; do
	count=$(( $count + 1 ))
	echo &amp;quot;&amp;quot;
	if [ &amp;quot;$1&amp;quot; = &amp;quot;$dst&amp;quot; ]; then
		ret=0
		handle_crypttab_line_start &amp;quot;$dst&amp;quot; &amp;quot;$src&amp;quot; &amp;quot;$key&amp;quot; &amp;quot;$opts&amp;quot; &amp;lt;&amp;amp;3 || ret=$?
		echo &amp;quot;&amp;quot;
		fsck -pv /dev/mapper/$dst
		echo &amp;quot;&amp;quot;
		mount -o $mopts /dev/mapper/$dst $mnt
	elif [ $count -ge $tablen ]; then
		ret=1
		device_msg &amp;quot;$1&amp;quot; &amp;quot;failed, not found in user_crypttab&amp;quot;
	else
		continue
	fi
	umount_fs
	log_action_end_msg $ret
	exit $ret
done 3&amp;lt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Zum Schluss noch mein  &lt;code&gt;user_cryptdisks_stop&lt;/code&gt;-Skript:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/sh

# user_cryptdisks_stop - wrapper around cryptsetup which parses
# /etc/user_crypttab, just like mount parses /etc/fstab.

# Initial code stolen from cryptdisks_stop by Jonas Meurer &amp;lt;jonas@freesources.org&amp;gt;
# Copyright (C) 2011 by Michael Rennecke &amp;lt;michael_rennecke@gmx.net&amp;gt;
# License: GNU General Public License, v2 or any later
# (http://www.gnu.org/copyleft/gpl.html)

CRYPTTAB=/etc/user_crypttab

set -e

if [ $# -lt 1 ]; then
	echo &amp;quot;usage: $0 &amp;lt;name&amp;gt;&amp;quot; &amp;gt;&amp;amp;2
	echo &amp;gt;&amp;amp;2
	echo &amp;quot;reads $CRYPTTAB and stops the mapping corresponding to &amp;lt;name&amp;gt;&amp;quot; &amp;gt;&amp;amp;2
	exit 1
fi

. /lib/cryptsetup/cryptdisks.functions

INITSTATE=&amp;quot;manual&amp;quot;
DEFAULT_LOUD=&amp;quot;yes&amp;quot;

if [ -x &amp;quot;/usr/bin/id&amp;quot; ] &amp;amp;&amp;amp; [ &amp;quot;$(/usr/bin/id -u)&amp;quot;  != &amp;quot;0&amp;quot; ]; then
	log_warning_msg &amp;quot;$0 needs root privileges&amp;quot;
	exit 1
fi

log_action_begin_msg &amp;quot;Stopping crypto disk&amp;quot;
echo &amp;quot;&amp;quot;

count=0
tablen=&amp;quot;$(egrep -vc &amp;quot;^[[:space:]]*(#|$)&amp;quot; &amp;quot;$CRYPTTAB&amp;quot;)&amp;quot;
egrep -v &amp;quot;^[[:space:]]*(#|$)&amp;quot; &amp;quot;$CRYPTTAB&amp;quot; | while read dst src key opts mnt mopts; do
	count=$(( $count + 1 ))
	if [ &amp;quot;$1&amp;quot; = &amp;quot;$dst&amp;quot; ]; then
		umount $mnt

		ret=0
		handle_crypttab_line_stop &amp;quot;$dst&amp;quot; &amp;quot;$src&amp;quot; &amp;quot;$key&amp;quot; &amp;quot;$opts&amp;quot; &amp;lt;&amp;amp;3 || ret=$?
	elif [ $count -ge $tablen ]; then
		ret=1
		device_msg &amp;quot;$1&amp;quot; &amp;quot;failed, not found in user_crypttab&amp;quot;
	else
		continue
	fi
	log_action_end_msg $ret
	exit $ret
done 3&amp;lt;&amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Die beiden Skripte kann nun &lt;code&gt;root&lt;/code&gt; ausführen, um Dateisysteme einzuhängen. Bei jeden einhängen
wird geschaut, ob ein &lt;a href=&#34;http://linux.die.net/man/8/fsck&#34;&gt;fsck&lt;/a&gt; nötig ist.
Mein Dank gilt &lt;a href=&#34;https://blog.meet-unix.org/&#34;&gt;meet-unix&lt;/a&gt;, er hat stand mit mit Rat zu
Seite, da ich noch etwas &lt;em&gt;Solaris&lt;/em&gt;-geschädigt bin.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>verschlüsseltes home automatisch mounten</title>
      <link>https://0rph3us.github.io/post/2011/03/verschl%C3%BCsseltes-home-automatisch-mounten/</link>
      <pubDate>Fri, 25 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>https://0rph3us.github.io/post/2011/03/verschl%C3%BCsseltes-home-automatisch-mounten/</guid>
      <description>

&lt;p&gt;Ich bin inzwischen auf &lt;a href=&#34;http://www.debian.org/&#34;&gt;Debian&lt;/a&gt; umgestiegen. Mein home sollte natürlich verschlüsselt sein. Wenn man zum verschlüsseln
&lt;a href=&#34;http://www.saout.de/misc/dm-crypt/&#34;&gt;dm-crypt&lt;/a&gt;/&lt;a href=&#34;http://linux.die.net/man/8/cryptsetup&#34;&gt;LUKS&lt;/a&gt; nutzt und die Dateisysteme in der &lt;code&gt;/etc/crypttab&lt;/code&gt; einbindet,
muss man beim booten das Passwort eingeben (Ich setzte voraus, dass man via Passwort verschlüsselt und nicht mit einem Keyfile). Es ist viel
interessanter, wenn das home beim anmelden automatisch gemountet wird. Das geht, wenn man &lt;a href=&#34;http://pam-mount.sourceforge.net/&#34;&gt;pam_mount&lt;/a&gt; benutzt.
Im folgenden beschreibe ich wie man ein verschlüsseltes home anlegt, welches automatisch gemountet wird.&lt;/p&gt;

&lt;h2 id=&#34;vorbereitung-anlegen-eines-volume-ich-nutze-lvm:a1b250d963e63d4efc9c74d05c217ed9&#34;&gt;Vorbereitung: Anlegen eines Volume (ich nutze lvm)&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cryptsetup luksFormat --cipher aes-cbc-essiv:sha256 /dev/data-group/home_rennecke
cryptsetup luksOpen /dev/data-group/home_rennecke data--group--home_rennecke_crypt
mkfs.ext4 /dev/mapper/data--group--home_rennecke_crypt
cryptsetup luksClose /dev/mapper/data--group--home_rennecke_crypt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Damit das home automatisch gemountet wird muss man in der &lt;code&gt;/etc/security/pam_mount.conf.xml&lt;/code&gt; das folgende einfügen:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- Volume definitions --&amp;gt;
&amp;lt;volume user=&amp;quot;rennecke&amp;quot; fstype=&amp;quot;crypt&amp;quot; path=&amp;quot;/dev/mapper/data--group-home--rennecke&amp;quot; mountpoint=&amp;quot;/home/rennecke&amp;quot; options=&amp;quot;fsck,noatime&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Das Passwort vom verschlüsselten home und das Passwort vom login müssen gleich sein! Wenn man sich nun einloggt, dann wird das home automatisch eingehangen.&lt;/p&gt;

&lt;h2 id=&#34;hinweis:a1b250d963e63d4efc9c74d05c217ed9&#34;&gt;Hinweis:&lt;/h2&gt;

&lt;p&gt;Das &lt;code&gt;pam_mount&lt;/code&gt;-Modul arbeitet nicht ganz transparent! mount zeigt nicht die wirklichen mount-Punkte an. Diese werden aber mit &lt;code&gt;cat /proc/mount&lt;/code&gt; angezeigt.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CF-Karten mounten</title>
      <link>https://0rph3us.github.io/post/2010/09/cf-karten-mounten/</link>
      <pubDate>Tue, 07 Sep 2010 00:00:00 +0000</pubDate>
      
      <guid>https://0rph3us.github.io/post/2010/09/cf-karten-mounten/</guid>
      <description>&lt;p&gt;
Wie ihr gelesen habt, bin ich unter die Digitalfotografen gegangen. Nun weiß ich endlich wozu der CF-Slot in meinen Notebook gut ist. Da muss man &lt;a href=&#34;http://de.wikipedia.org/wiki/CompactFlash&#34;&gt;Compact Flash&lt;/a&gt;-Karten hineinstecken und solche stecken in meiner Kamera. Das dumme ist nur, dass mein Debian die CF-Karten nicht automatisch mountet. Zuerst habe ich nachgesehen, welches Device die CF-Karten haben. Anschließend erstellt man ein Verzeichnis in das die CF-Karten gemountet werden sollen.&lt;/p&gt;
&lt;pre lang=&#34;bash&#34;&gt;
rennecke@trantor ~ % blkid
/dev/sda1: UUID=&#34;5C8CF5697CA93BD8&#34; TYPE=&#34;ntfs&#34;
/dev/sda5: UUID=&#34;f1b2836f-81bf-4f75-9ae0-f2c284871891&#34; TYPE=&#34;swap&#34;
/dev/sda6: LABEL=&#34;debian-root&#34; UUID=&#34;c00a4da53-1763-42e1-878d-3e096cad760b&#34; TYPE=&#34;ext4&#34;
/dev/sda7: UUID=&#34;60eca5b7-09ef-4b82-bf59-1a8360c8c6c1&#34; TYPE=&#34;crypto_LUKS&#34;
/dev/mapper/home: UUID=&#34;6cbebba6-e725-4549-bafe-8809ff73f27f&#34; TYPE=&#34;ext4&#34;
/dev/hda1: SEC_TYPE=&#34;msdos&#34; LABEL=&#34;EOS_DIGITAL&#34; TYPE=&#34;vfat&#34;
rennecke@trantor ~ % su
Passwort:
root@trantor /home/rennecke $ mkdir /media/flash
&lt;/pre&gt;
&lt;p&gt;Nun weiß ich, dass meine CF-Karten das Device &lt;tt&gt;/dev/hda1&lt;/tt&gt; haben. Nun füge ich die folgende Zeile der &lt;tt&gt;/etc/fstab&lt;/tt&gt; hinzu:&lt;/p&gt;
&lt;pre lang=&#34;config&#34;&gt;
/dev/hda1       /media/flash    auto        rw,user,noauto,exec     0       0
&lt;/pre&gt;
&lt;p&gt;
Nun kann man als  normaler User mittels&lt;/p&gt;
&lt;pre lang=&#34;bash&#34;&gt;
rennecke@trantor ~ % mount /media/flash
rennecke@trantor ~ % umount /media/flash
&lt;/pre&gt;
&lt;p&gt;die CF-Karte mounten und abmounten. Alternativ kann man das ganz nun auch grafisch mounten. Wo man klicken muss hängt vom Window-Manager ab.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Neues Logo für Iceweasel</title>
      <link>https://0rph3us.github.io/post/2010/08/neues-logo-f%C3%BCr-iceweasel/</link>
      <pubDate>Mon, 16 Aug 2010 00:00:00 +0000</pubDate>
      
      <guid>https://0rph3us.github.io/post/2010/08/neues-logo-f%C3%BCr-iceweasel/</guid>
      <description>&lt;p&gt;Es werden &lt;a href=&#34;http://mozilla.debian.net/en-US/logos/&#34;&gt;neue Logos&lt;/a&gt; für Ice[weasel | ape | dove] gesucht.
Ich habe mir mit &lt;a href=&#34;http://binfalse.de&#34;&gt;Martin&lt;/a&gt;, einmal ein Paar gedanken gemacht. Das Ergebinis sieht wie folgt aus:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://0rph3us.github.io/Iceweasel.png&#34; title=&#34;&#34; data-lightbox=&#34;set1&#34; data-title=&#34;alternatives Iceweasel-Logo&#34;&gt;&lt;img src=&#34;https://0rph3us.github.io/Iceweasel-thumbnail.png&#34; alt=&#34;alternatives Iceweasel-Logo&#34;&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>