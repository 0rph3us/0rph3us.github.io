<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Haproxy on Michael im Netz</title>
    <link>https://0rph3us.github.io/tags/haproxy/</link>
    <description>Recent content in Haproxy on Michael im Netz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>de-DE</language>
    <copyright>Diese Seite ist unter der &lt;a href=&#34;http://creativecommons.org/licenses/by-sa/4.0/&#34;&gt;Creative Commons Attribution-ShareAlike 4.0 International License&lt;/a&gt; lizenziert.</copyright>
    <lastBuildDate>Mon, 28 Dec 2015 22:37:08 +0100</lastBuildDate>
    <atom:link href="https://0rph3us.github.io/tags/haproxy/rss/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LibreSSL und HAProxy</title>
      <link>https://0rph3us.github.io/post/2015/12/libressl-und-haproxy/</link>
      <pubDate>Mon, 28 Dec 2015 22:37:08 +0100</pubDate>
      
      <guid>https://0rph3us.github.io/post/2015/12/libressl-und-haproxy/</guid>
      <description>

&lt;p&gt;Wenn man &lt;a href=&#34;https://www.raspbian.org/&#34;&gt;Raspbian&lt;/a&gt; einsetzt (oder eine fast beliebige andere Linux-Distribution)
hat man das &lt;em&gt;Problem&lt;/em&gt;, dass die mitgelieferten Webserver und Loadbalancer &lt;a href=&#34;https://www.openssl.org/&#34;&gt;OpenSSL&lt;/a&gt;
nutzen. OpenSSL ist 2015 durch eine Sicherheitslücken negativ aufgefallen, außerdem
gibt es keine Unterstützung&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:bddda923aec4e8e8e36a0066c730c514:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:bddda923aec4e8e8e36a0066c730c514:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; für &lt;a href=&#34;https://blog.cloudflare.com/do-the-chacha-better-mobile-performance-with-cryptography/&#34;&gt;ChaCha20 Cipher Suiten&lt;/a&gt;. Diese haben den Vorteil,
dass sie in Software schneller sind als &lt;a href=&#34;https://de.wikipedia.org/wiki/Advanced_Encryption_Standard&#34;&gt;AES&lt;/a&gt;. Das macht sich insbesondere bei meinen
Raspberry Pi und bei Smartphones bemerkbar. Diese haben Hardware AES.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.libressl.org/&#34;&gt;LibreSSL&lt;/a&gt; ist eine Alternative zu OpenSSL. Es hat die Unterstützung für ChaCha20. Bei
LibreSSL liegt der Fokus auf Sicherheit und weniger auf die Unterstützung von alten
Schnittstellen. Deswegen ist davon auszugehen, dass es in der Zukunft auch weniger
kritische Sicherheitslücken geben wird.&lt;/p&gt;

&lt;h2 id=&#34;haproxy:bddda923aec4e8e8e36a0066c730c514&#34;&gt;HAProxy&lt;/h2&gt;

&lt;p&gt;In meinen Setup ist &lt;a href=&#34;http://www.haproxy.org/&#34;&gt;HAProxy&lt;/a&gt; vor dem Webserver (Nginx). Es ist vielleicht sinnlos
einen Loadbalancer auf dem Pi zu nutzen aber ich finde, dass sich HAProxy ein einigen
Stellen einfacher konfigurieren lässt als Nginx.&lt;/p&gt;

&lt;h2 id=&#34;haproxy-mit-libressl-und-pcre-bauen:bddda923aec4e8e8e36a0066c730c514&#34;&gt;HAProxy mit LibreSSL und PCRE bauen&lt;/h2&gt;

&lt;p&gt;kopiere das folgende Script in eine Datei und führe es aus:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash

# names of latest versions of each package
export HAPROXY_VERSION=1.6.3
export VERSION_PCRE=pcre-8.38
export VERSION_LIBRESSL=libressl-2.3.1
export VERSION_HAPROXY=haproxy-$HAPROXY_VERSION

# URLs to the source directories
export SOURCE_LIBRESSL=ftp://ftp.openbsd.org/pub/OpenBSD/LibreSSL/
export SOURCE_PCRE=ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/
export SOURCE_HAPROXY=http://www.haproxy.org/download


# clean out any files from previous runs of this script
rm -rf build
mkdir build

# proc for building faster
NB_PROC=$(grep -c ^processor /proc/cpuinfo)

# ensure that we have the required software
#sudo apt-get -y install curl wget build-essential libgd-dev libgeoip-dev checkinstall git

# grab the source files
echo &amp;quot;Download sources&amp;quot;
wget -P ./build &amp;quot;${SOURCE_PCRE}${VERSION_PCRE}.tar.gz&amp;quot;
wget -P ./build &amp;quot;${SOURCE_LIBRESSL}${VERSION_LIBRESSL}.tar.gz&amp;quot;
wget -P ./build &amp;quot;${SOURCE_HAPROXY}/$(echo $HAPROXY_VERSION | cut -d. -f 1-2)/src/$VERSION_HAPROXY.tar.gz&amp;quot;

# expand the source files
echo &amp;quot;Extract Packages&amp;quot;
cd build || exit 1

tar xfz &amp;quot;${VERSION_HAPROXY}.tar.gz&amp;quot;
tar xfz &amp;quot;${VERSION_LIBRESSL}.tar.gz&amp;quot;
tar xfz &amp;quot;${VERSION_PCRE}.tar.gz&amp;quot;
cd ../ || exit 1

export BPATH=&amp;quot;${PWD}/build&amp;quot;
export STATICLIBSSL=&amp;quot;${BPATH}/${VERSION_LIBRESSL}&amp;quot;

# build static LibreSSL
echo &amp;quot;Configure &amp;amp; Build LibreSSL&amp;quot;
cd &amp;quot;${STATICLIBSSL}&amp;quot; || exit 1
./configure --prefix=&amp;quot;${STATICLIBSSL}/_openssl/&amp;quot; --enable-shared=no &amp;amp;&amp;amp; make install-strip -j &amp;quot;${NB_PROC}&amp;quot;

# build pcre
export STATICLIPCRE=&amp;quot;${BPATH}/${VERSION_PCRE}&amp;quot;
cd &amp;quot;${STATICLIPCRE}&amp;quot; || exit 1
./configure --prefix=&amp;quot;${STATICLIPCRE}/_pcre&amp;quot; --enable-shared=no --enable-utf8 --enable-jit
make -j &amp;quot;${NB_PROC}&amp;quot;
make install


echo &amp;quot;Build HAProxy&amp;quot;
cd &amp;quot;${BPATH}/${VERSION_HAPROXY}&amp;quot; || exit 1

make \
-j &amp;quot;${NB_PROC}&amp;quot; \
TARGET=linux2628 \
USE_STATIC_PCRE=1 \
USE_PCRE_JIT=1 \
PCRE_LIB=&amp;quot;${STATICLIPCRE}/_pcre/lib&amp;quot; \
PCRE_INC=&amp;quot;${STATICLIPCRE}/_pcre/include&amp;quot; \
USE_OPENSSL=1 \
SSL_INC=&amp;quot;${STATICLIBSSL}/_openssl/include&amp;quot; \
SSL_LIB=&amp;quot;${STATICLIBSSL}/_openssl/lib&amp;quot; \
USE_ZLIB=1 \
DEFINE=&amp;quot;-fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2&amp;quot;


echo &amp;quot;All done.&amp;quot;
echo &amp;quot;become root and type: &amp;quot;
echo &amp;quot;  cp build/haproxy-${HAPROXY_VERSION}/haproxy /usr/local/sbin&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;todo:bddda923aec4e8e8e36a0066c730c514&#34;&gt;ToDo&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Konfiguration von HAProxy&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:bddda923aec4e8e8e36a0066c730c514:1&#34;&gt;In den kommenden Versionen von OpenSSL wird es Unterstützung für ChaCha20 Cipher Suiten geben. Ich finde die Quelle gerade nicht :-(
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:bddda923aec4e8e8e36a0066c730c514:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Deterministisches Loadbalancing</title>
      <link>https://0rph3us.github.io/post/2015/09/deterministisches-loadbalancing/</link>
      <pubDate>Thu, 17 Sep 2015 05:58:20 +0200</pubDate>
      
      <guid>https://0rph3us.github.io/post/2015/09/deterministisches-loadbalancing/</guid>
      <description>

&lt;p&gt;Beim Loadbalancing verteilet ein Loadbalancer, wie HAProxy die Last auf mehrere Server. In vielen Fällen macht man das Roud-Robin oder nach Last. Es ergibt auch durchaus Sinn nach einer ID die Backendserver auszuwählen. Daraus ergeben sich zwei Vorteile. Zum einen kann es für Backendserver besser sein, wenn die selbe ID immer auf den selben Server kommt. Dadurch können interene Caches evtl. besser ausgenutzt werden. Da eine ID immer einen Server zugeordnet ist, wird das Loadbalancing deterministisch. Das hat den unschätzbaren Vorteil, dass z.B. eine Anfrage die fehl schlägt immer fehl schlägt.&lt;/p&gt;

&lt;p&gt;Bei meinen Arbeitgeber hatten wir das Problem, dass bestimmte URLs konsequent nicht gehen. Bei einen naiven Test hat der Entwickler festgestellt, dass sein Dienst auf die URL korrekt antwortet. Durch meinen Test der Proxykonfiguration konnte ich ausschließen, dass das Routing im HAProxy Schuld am Fehlverhalten ist. Da dieser Dienst mit einer konsistenten Hashfunktion deterministisch geroutet wird, trat der Fehler immer auf. Dabei stellte sich heraus, dass eine Instanz nicht in der richtigen Version&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:69d192c4ad0750c8f53fe9a830e4a70c:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:69d192c4ad0750c8f53fe9a830e4a70c:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; lief.&lt;/p&gt;

&lt;p&gt;Da Fehler immer wieder vorgekommen, ist es wichtig sie schnell und zuverlässig zu beseitigen. In solchen Situationen ist es besser, den Fehler &lt;strong&gt;immer&lt;/strong&gt; zu haben, anstatt bei jeder x-ten Anfrage.&lt;/p&gt;

&lt;h2 id=&#34;umsetzung-von-deterministischen-loadbalancing:69d192c4ad0750c8f53fe9a830e4a70c&#34;&gt;Umsetzung von deterministischen Loadbalancing&lt;/h2&gt;

&lt;p&gt;Mein favorisierter Loadbalancer für HTTP ist &lt;a href=&#34;http://www.haproxy.org/&#34;&gt;HAProxy&lt;/a&gt;. Ich hatte die Anforderung nach einer ID, welche im Path der URL steht zu balancen. Das ist nicht ganz offensichtlich mit HAProxy. Meine Umsetzung sieht wie folgt aus:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;backend Webserver
        balance hdr(X-MyID)
        hash-type consistent

        http-request set-header     X-MyID %[url]
        http-request replace-header X-MyID ^/foo/bar/lol/([0-9]{5,5}).* \1
        http-request replace-header X-MyID ^/foo/barbar/([0-9]{5,5}).* \1

        server webserver1 10.0.0.1:80
        server webserver2 10.0.0.2:80
        server webserver3 10.0.0.3:80
        server webserver4 10.0.0.4:80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Als erstes wird die URL in den Header &lt;strong&gt;X-MyID&lt;/strong&gt; kopiert. Die folgenden regulären Ausdrücke schmeißen alles weg, außer die 5-stellige ID. Falls keiner der beiden Ausdrücke angewendet werden kann, steht die URL noch im Header. Dann wird diese als Kriterium für die Verteilung genommen. Der &lt;code&gt;hash-type consistent&lt;/code&gt; bei HAProxy verteilt die Anfragen auf die anderen Server, falls ein Server aus dem Loadbalancing geht.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:69d192c4ad0750c8f53fe9a830e4a70c:1&#34;&gt;Es gab auch schon den Fall, dass eine Instanz auf bestimmte Anfragen nicht beantworten konnte, weil ein Teil der Applikation Ammok lief. Dieser Fehler war auch nicht von außen ersichtlich.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:69d192c4ad0750c8f53fe9a830e4a70c:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Guten Morgen</title>
      <link>https://0rph3us.github.io/post/2015/09/guten-morgen/</link>
      <pubDate>Tue, 15 Sep 2015 05:50:08 +0200</pubDate>
      
      <guid>https://0rph3us.github.io/post/2015/09/guten-morgen/</guid>
      <description>

&lt;p&gt;Ich habe schon länger keinen neuen Post hinterlassen. Es
lag unter anderen daran, dass ich umgezogen bin. Der größte
Teil des Umzuges ist inzwischen geschafft und alles ist an
seinen Platz.&lt;/p&gt;

&lt;p&gt;In der Zwischenzeit war nicht untätig, Ich habe mit &lt;a href=&#34;http://www.haproxy.org/&#34;&gt;HAProxy&lt;/a&gt;
etwas experimentiert. Ziel war es Zertifikate mit RSA und &lt;a href=&#34;http://www.cs.uni-potsdam.de/ti/lehre/05-Kryptographie/slides/Elliptische_Kurven.pdf&#34;&gt;Elliptische Kurven&lt;/a&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3fd9ce4c42cd011d05713db9016f8f87:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3fd9ce4c42cd011d05713db9016f8f87:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; für den selben Hostname/FQDN anzubieten.&lt;/p&gt;

&lt;p&gt;Weswegen möchte man das eigenlich machen? Zertifikate mit
RSA sind sehr lang (größergleich 4096 Bit), wenn man
paranoit ist. Diese langen Zertifikate kosten Zeit bei der Übertragung und Rechenkraft beim Handshake. Aus diesem Grud liegt es nahe Zertifikate mit Elliptischen Kurven zu nutzen. Die größten Kurven haben eine Länge von 571 Bit. Dabei wird eine sehr höhere Sicherheit erreicht, als mit 8096 Bit langen RSA Schlüssel und sie lassen schneller berechnen.&lt;/p&gt;

&lt;p&gt;Da ich auf meinen Raspberry Pi zahlreiche Dienste betreibe, welche per SSL abgesichert sind, habe ich Stern-Zertifiake generiert. Wenn HAProxy eine eigene (Sub)&lt;a href=&#34;https://de.wikipedia.org/wiki/Zertifizierungsstelle&#34;&gt;CA&lt;/a&gt; hat, dann ist es möglich, dass bei jeder Anfrage mit einen neuen Hostname ein neues Zertifikat generiert wird.&lt;/p&gt;

&lt;h2 id=&#34;umsetzung:3fd9ce4c42cd011d05713db9016f8f87&#34;&gt;Umsetzung&lt;/h2&gt;

&lt;p&gt;In den aktuellen Developer Builds von HAProxy, aktuell 1.6-dev4 ist möglich ECC und RSA Zertifikate auf der selben IP und Port zu betreiben. Weiherhin ist es möglich Zertifikate zu generieren. Das dumme war nur, dass es nicht richtig mit Elliptischen Kurven funktioniert. Nach einiger Diskussion über den Sinn dieses Setups hat mit Christopher Faulet einen Patch geschieben, welcher funktioniert. Da der Patch auch bei mir funktioniert, gibt Christopher upstream.&lt;/p&gt;

&lt;h3 id=&#34;testconfig:3fd9ce4c42cd011d05713db9016f8f87&#34;&gt;Testconfig&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;global
        daemon
        maxconn 256

        ssl-default-bind-ciphers AES256+EECDH:AES256+EDH
        ssl-default-bind-options force-tlsv12
        tune.ssl.default-dh-param 4096
        tune.ssl.lifetime 600


defaults
        mode http
        timeout connect 5000ms
        timeout client 50000ms
        timeout server 50000ms


frontend ssl-relay
        mode tcp
        bind 0.0.0.0:443

        use_backend ssl-ecc if { req.ssl_ec_ext 1 }
        default_backend ssl-ecc


backend ssl-ecc
        mode tcp

        server ecc unix@/var/run/haproxy_ssl_ecc.sock send-proxy-v2


backend ssl-rsa
        mode tcp

        server rsa unix@/var/run/haproxy_ssl_rsa.sock send-proxy-v2


listen webfarm
        bind unix@/var/run/haproxy_ssl_ecc.sock accept-proxy ssl crt /etc/haproxy/ecc_test.rennecke.dyndns.dk.pem tls-ticket-keys /etc/haproxy/ticket_keys ca-sign-file /etc/haproxy/ecc_subca.pem user nobody generate-certificates ecdhe secp521r1
        bind unix@/var/run/haproxy_ssl_rsa.sock accept-proxy ssl crt /etc/haproxy/rsa_star.rennecke.dyndns.dk.pem tls-ticket-keys /etc/haproxy/ticket_keys ecdhe secp521r1 user nobody
        mode http

        acl admin               path_beg /haproxy
        use_backend admin       if admin

        server nginx 127.0.0.1:88 check

backend admin
        stats enable
        stats hide-version
        stats show-legends
        stats realm Haproxy\ Statistics
        stats uri /haproxy?stats
        stats refresh 30s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In dieser Config generiere ich nur die ECC-Zertifikate für alle Hosts, außer &lt;code&gt;test.rennecke.dyndns.dk&lt;/code&gt;. Das ganze Setup funktioniert, aber es läuft noch nicht ganz rund.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:3fd9ce4c42cd011d05713db9016f8f87:1&#34;&gt;Man schreibt auch oft &lt;a href=&#34;https://de.wikipedia.org/wiki/Elliptic_Curve_Cryptography&#34;&gt;ECC&lt;/a&gt; (Elliptic Curve) Cryptography
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3fd9ce4c42cd011d05713db9016f8f87:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>